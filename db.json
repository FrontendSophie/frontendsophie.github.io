{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/clean-blog/LICENSE","hash":"8726b416df4f067cff579e859f05c4b594b8be09","modified":1523177846685},{"_id":"themes/clean-blog/_config.yml","hash":"aa4241e4ad211e625b928ad3be579263d62e6400","modified":1523195560000},{"_id":"themes/clean-blog/README.md","hash":"861dd2f959ab75d121226f4f3e2f61f4bc95fddb","modified":1523177846685},{"_id":"source/_posts/layout1.md","hash":"09fd0c9841f5d1ecba1b7db629d02c37b95ea875","modified":1523198131058},{"_id":"source/_posts/layout2.md","hash":"a367c8a7f35db52311f4766948dec328f470b846","modified":1523198400688},{"_id":"source/_posts/oop2.md","hash":"ab2b7651b53d70e3cc4f862b6abfd8028c1cd933","modified":1523197898000},{"_id":"source/_posts/oop1.md","hash":"0d724de51957207196dbf20426218a814d6b9c16","modified":1523198049254},{"_id":"source/categories/index.md","hash":"0e53ff59c13e4c37a0abfccbc5c6d7620af06de0","modified":1523184671000},{"_id":"source/tags/index.md","hash":"0664944c653060c972dbb5f18c0a08881f9f811c","modified":1523184674000},{"_id":"themes/clean-blog/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1523177846676},{"_id":"source/_posts/type.md","hash":"42a6702adefe40132390c47ca03d7cf50fd3c597","modified":1523198980141},{"_id":"themes/clean-blog/.git/config","hash":"0037ed70f19e4933b19020ad514d8e9e049174f1","modified":1523177846680},{"_id":"themes/clean-blog/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1523177803684},{"_id":"themes/clean-blog/.git/index","hash":"86da2c937061d5bdec5505f00f8af6e2fc7994f8","modified":1523180717531},{"_id":"themes/clean-blog/.git/packed-refs","hash":"78749f2f1de403b00552d862f076d37586b9b819","modified":1523177846674},{"_id":"themes/clean-blog/languages/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1523177846686},{"_id":"themes/clean-blog/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1523177846686},{"_id":"themes/clean-blog/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1523177846686},{"_id":"themes/clean-blog/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1523177846686},{"_id":"themes/clean-blog/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1523177846686},{"_id":"themes/clean-blog/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1523177846686},{"_id":"themes/clean-blog/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1523177846687},{"_id":"themes/clean-blog/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1523177846687},{"_id":"themes/clean-blog/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1523177846687},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1523177846687},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1523177846687},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"f2ef73afc3d275333329bb30b9369b82e119da76","modified":1523177846690},{"_id":"themes/clean-blog/layout/index.ejs","hash":"d751816fed50c268ba18642d8ba5d42c4d5b5cc7","modified":1523183743343},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"da2f9018047924ddaf376aee5996c7ddc06cebc1","modified":1523177846690},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1523177846690},{"_id":"themes/clean-blog/layout/page.ejs","hash":"591af587e1aae962950de7e79bd25c1f060c69ac","modified":1523177846690},{"_id":"themes/clean-blog/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1523177803687},{"_id":"themes/clean-blog/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1523177803685},{"_id":"themes/clean-blog/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1523177803689},{"_id":"themes/clean-blog/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1523177803690},{"_id":"themes/clean-blog/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1523177803686},{"_id":"themes/clean-blog/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1523177803691},{"_id":"themes/clean-blog/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1523177803688},{"_id":"themes/clean-blog/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1523177803686},{"_id":"themes/clean-blog/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1523177803688},{"_id":"themes/clean-blog/.git/logs/HEAD","hash":"f2b87909e4b8eff609f9877ff620b6ffb02ecaea","modified":1523177846678},{"_id":"themes/clean-blog/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1523177803692},{"_id":"themes/clean-blog/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1523177803683},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"3d8d98c6545b8332a6d6ed4f8b00327df03ea945","modified":1523177846687},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1523177846688},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"e433df4e245e2d4c628052c6e59966563542d94d","modified":1523177846688},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"80970a6cfbf9b1abe0c472636b321a9be08fdc43","modified":1523177846687},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"6136434be09056c1466149cecb3cc2e80d107999","modified":1523177846688},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"0e7aa9da47f29b2312d9d3165c067576ebca77cf","modified":1523177846688},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"3fedb75436439d1d6979b7e4d20d48a593e12be4","modified":1523177846688},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"288893155feb0cbd485722ab8816e73a63e99472","modified":1523184376883},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"21e4f28909f4a79ff7d9f10bdfef6a8cb11632bf","modified":1523177846688},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1523177846689},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"ba299316400499e9ede154e9627cafb7ce411888","modified":1523177846689},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1523177846689},{"_id":"themes/clean-blog/layout/_partial/tag-category-index.ejs","hash":"10cdc1b7866999c714a666557c150d2c79c1fba9","modified":1523177846689},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"596aa41115997cae5bc18868b622f0b6ecfb7dfc","modified":1523183814064},{"_id":"themes/clean-blog/source/css/article.styl","hash":"79a54059fa98dd40ba3730c1c15c4bda8f8fb56d","modified":1523184070487},{"_id":"themes/clean-blog/source/css/base.styl","hash":"f0a6fcf58fe515e1359acde0ed34081f580ec7a3","modified":1523177846690},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"892f55e8a71f2e23a52e48e217dad3303bbad913","modified":1523177846691},{"_id":"themes/clean-blog/source/css/style.styl","hash":"c40dc495a41007d21c59f342ee42b2d31d7b5ff4","modified":1523177846691},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"cd82df5ca8dfbcfec12d833f01adfac00878e835","modified":1523177846691},{"_id":"themes/clean-blog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1523177846692},{"_id":"themes/clean-blog/.git/refs/heads/master","hash":"0f3b4e362de29ccd7fa4b5983e9a0ea546623577","modified":1523177846678},{"_id":"themes/clean-blog/.git/objects/pack/pack-02dee367c9c12b2f882a71e10c426c5744101cc2.idx","hash":"356081245bc23eedce1f0863658124b946c4c492","modified":1523177846654},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1523177846694},{"_id":"themes/clean-blog/.git/logs/refs/heads/master","hash":"f2b87909e4b8eff609f9877ff620b6ffb02ecaea","modified":1523177846678},{"_id":"themes/clean-blog/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1523177846676},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1523177846693},{"_id":"themes/clean-blog/.git/logs/refs/remotes/origin/HEAD","hash":"f2b87909e4b8eff609f9877ff620b6ffb02ecaea","modified":1523177846676},{"_id":"themes/clean-blog/.git/objects/pack/pack-02dee367c9c12b2f882a71e10c426c5744101cc2.pack","hash":"be53a2763692f8f8364ad89d023ec81c736988ce","modified":1523177846654},{"_id":"public/categories/index.html","hash":"3845ada331d6e2ff07178c7541066805e9fba4af","modified":1523200024503},{"_id":"public/2018/02/19/type/index.html","hash":"5206bd91022596ec6ed8d99152c22d1346fb74cf","modified":1523200024503},{"_id":"public/tags/index.html","hash":"fe6f30088e6714386cd50af2bd25a663c247e81a","modified":1523200024503},{"_id":"public/2017/02/25/oop2/index.html","hash":"c0b23de487c0b0962c21c73ecc3f88105060659f","modified":1523200024503},{"_id":"public/2017/02/22/oop1/index.html","hash":"d2a19c2660bb64e696b4797ee8d562ab4a79d090","modified":1523200024503},{"_id":"public/archives/index.html","hash":"bd9ddbdedf3fb1f634a061c9584d66b689131783","modified":1523200024503},{"_id":"public/archives/2017/index.html","hash":"f9f31228f114cbbb8b07b3ad312fe0c088d686ba","modified":1523200024504},{"_id":"public/archives/2017/02/index.html","hash":"5e10ab41bae7c417f7600d5f3973bd74d883c8af","modified":1523200024504},{"_id":"public/archives/2017/07/index.html","hash":"cf977e8637b18d27b40919906944b28cd4a01469","modified":1523200024504},{"_id":"public/archives/2018/index.html","hash":"3df2186baaac997f7914bf994db32f66ce98a263","modified":1523200024504},{"_id":"public/archives/2018/02/index.html","hash":"760b18566b0854e714d4190c5d83f39dac239865","modified":1523200024504},{"_id":"public/categories/CSS/index.html","hash":"52d0ab4ff2a96b62e1c2773bacc0ea1a0ac0aa55","modified":1523200024504},{"_id":"public/categories/JavaScript/index.html","hash":"43f0f49e5322790765b366c0e06566f753374f20","modified":1523200024504},{"_id":"public/index.html","hash":"d87402b9335c982721b186c788c3a7ce9987b028","modified":1523200024504},{"_id":"public/tags/Layout/index.html","hash":"6f9772756ee6e8e5ff6577547cb81f43510be60d","modified":1523200024504},{"_id":"public/tags/Interview/index.html","hash":"10d6b83e0020793f787b8fba9fdba3ef30ed93b6","modified":1523200024504},{"_id":"public/tags/OOP/index.html","hash":"86a749cb2c1cf972b08c9c4e24dc20430890848f","modified":1523200024504},{"_id":"public/2017/07/07/layout2/index.html","hash":"6718d0bc10ab35ca4b2eedb4cac0df0bda31889c","modified":1523200024504},{"_id":"public/2017/07/06/layout1/index.html","hash":"110f626668b92dfe4f4205dbcea15309db0292ed","modified":1523200024505},{"_id":"public/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1523200024506},{"_id":"public/css/base.css","hash":"5bdbdf83ad61e80c537bd75b5442c8b0aac1e0f6","modified":1523200024813},{"_id":"public/css/article.css","hash":"5ae83a5c3219f03fd591f7e54ce78a1d463f25f0","modified":1523200024813},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523200024813},{"_id":"public/css/mixins.css","hash":"45146e7f4346351cd7f364de344aecf9574475f9","modified":1523200024813},{"_id":"public/css/style.css","hash":"41b82d732d3a4d0dce4c15f9273700b0d64cf1ab","modified":1523200024813},{"_id":"public/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1523200024813},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1523200024815}],"Category":[{"name":"CSS","_id":"cjfqxysl800049wfrbhziwo2c"},{"name":"JavaScript","_id":"cjfqxyslf000b9wfr2va8brac"}],"Data":[],"Page":[{"title":"Categories","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ntype: categories\n---\n","date":"2018-04-08T15:00:30.915Z","updated":"2018-04-08T10:51:11.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjfqxysl500019wfr0glbvoai","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ntype: tags\n---\n","date":"2018-04-08T15:00:30.914Z","updated":"2018-04-08T10:51:14.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjfqxysl700039wfrbvywsc1a","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"居中布局","date":"2017-07-06T14:33:13.000Z","_content":"\n本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。\n\n### 水平居中\n\n在父子元素宽度都是未知的情况下实现水平居中，难点在于要先设置子元素的宽度变成内容宽，然后设置父元素或者子元素的样式使其居中。\n\n```\n<div class=\"parent\"</div>\n  <div class=\"child\"><div>\n</div>\n```\n\n1、 `inline-block` + `text-align`  \n原理：`inline-block`元素的宽度是内容宽，`text-align`对`inline`元素以及`inline-block`元素都会起作用。  \n优点：兼容性很好。  \n缺点：`text-align: center`会被继承，`.child`里面有文字的话就会被居中。\n\n```\n.parent {\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n```\n\n2、 `table` + `margin`  \n原理：`block`元素定宽+`margin: 0 auto`可以实现水平居中。`table`元素表现上很像`block`元素，但是`table`元素的宽度也是内容宽。  \n优点：只需要设置子元素的样式，不用关心父元素，同时 IE8 以上浏览器兼容性很好。\n\n```\n.child {\n  display: table;\n  margin: 0 auto;\n}\n```\n\n3、 `absolute` + `transform`  \n原理：`absolute`元素默认没有宽度，宽度由内容决定。`left: 50%`是相对于`.parent`的 50%，`.child`的左边就会抵达`.parent`的中间。然后`translate`内部百分比的参照物是自己，`translateX(-50%)`就是以`.child`自身宽度的 50%向左偏移从而使得元素居中。  \n优点：绝对定位脱离文档流，`.child`不会对其他元素产生影响。  \n缺点：`transform`是 CSS3 属性，不兼容 IE8。\n\n```\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n```\n\n4、 `flex` + `justify-content`  \n原理：设置`flex`以后子元素就变成了`flex-item`， `flex-item`默认情况下宽度是`auto`就是内容宽。除了对父元素设置`justify-content: center`， 对子元素设置`margin: 0 auto`也能使其居中，类似`table`元素。  \n优点：只需要设置父元素的样式。  \n缺点：`flex`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  display: flex;\n  justify-content: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  margin: 0 auto;\n}\n```\n\n&nbsp;\n\n### 垂直居中\n\n在父子元素高度都是未知的情况下实现垂直居中，难点在于理解`vertical-align`的使用场景。\n\n```\n<div class=\"parent\"</div>\n  <div class=\"child\"><div>\n</div>\n```\n\n1、 `table-cell` + `vertical-align`  \n原理：`vertical-align: middle`可以作用在`inline`元素、`inline-block`元素以及`table-cell`元素上。只有在`tabel-cell`元素中是用来设置单元格内容的对齐方式。当设置在行内元素上时，效果是设置这个元素相对于所在行基线的垂直对齐。题外话，如果想要和`text-align: center`实现文本水平居中一样实现文本的垂直居中，应该用`line-height`，将其高度设置成元素高度即可。  \n优点：兼容性很好。\n\n```\n.parent {\n  display: table-cell;\n  vertical-align: middle;\n}\n```\n\n2、 `absolute` + `transform`  \n原理：参照水平居中方案三。  \n优点：子元素不会干扰其他元素。  \n缺点：`transform`是 CSS3 属性，IE8 不兼容。而且当父容器未设置高度，即高度通过子元素撑开时，子元素设置`absolute`之后脱离文档流，父容器就会没有高度，以致影响后续布局。\n\n```\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n```\n\n3、 `flex` + `align-items`  \n原理：`flex-item`的`align-items`属性默认值是`strech`，子元素会被拉伸到和父容器一样高。除了设置父元素的`align-items: center`使子元素继承得以居中，还可以直接单独设置子元素的`align-self: center`达到垂直居中。  \n优点：只需要设置父容器样式。  \n缺点：`flex`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  display: flex;\n  align-items: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n}\n```\n\n&nbsp;\n\n### 水平垂直居中\n\n在父子元素宽度、高度都是未知的情况下实现水平、垂直居中，综合上述方法即可。\n\n```\n<div class=\"parent\"</div>\n  <div class=\"child\"><div>\n</div>\n```\n\n1、`inline-block` + `text-align` + `table-cell` + `vertical-align`  \n优点：兼容性很好。\n\n```\n.parent {\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n```\n\n2、`absolute` + `transform`\n优点：子元素不会干扰其他元素。  \n缺点：`transform`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n3、`flex` + `justify-content` + `align-items`  \n优点：只需要设置父元素样式。  \n缺点：`flex`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n/* other solution 1 */\n.parent {\n  display: flex;\n  align-items: center;\n}\n.child {\n  margin: 0 auto;\n}\n\n/* other solution 2 */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n  margin: 0 auto;\n}\n```\n","source":"_posts/layout1.md","raw":"---\ntitle: 居中布局\ndate: 2017-07-06 22:33:13\ncategories: CSS\ntags: [Layout, Interview]\n---\n\n本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。\n\n### 水平居中\n\n在父子元素宽度都是未知的情况下实现水平居中，难点在于要先设置子元素的宽度变成内容宽，然后设置父元素或者子元素的样式使其居中。\n\n```\n<div class=\"parent\"</div>\n  <div class=\"child\"><div>\n</div>\n```\n\n1、 `inline-block` + `text-align`  \n原理：`inline-block`元素的宽度是内容宽，`text-align`对`inline`元素以及`inline-block`元素都会起作用。  \n优点：兼容性很好。  \n缺点：`text-align: center`会被继承，`.child`里面有文字的话就会被居中。\n\n```\n.parent {\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n```\n\n2、 `table` + `margin`  \n原理：`block`元素定宽+`margin: 0 auto`可以实现水平居中。`table`元素表现上很像`block`元素，但是`table`元素的宽度也是内容宽。  \n优点：只需要设置子元素的样式，不用关心父元素，同时 IE8 以上浏览器兼容性很好。\n\n```\n.child {\n  display: table;\n  margin: 0 auto;\n}\n```\n\n3、 `absolute` + `transform`  \n原理：`absolute`元素默认没有宽度，宽度由内容决定。`left: 50%`是相对于`.parent`的 50%，`.child`的左边就会抵达`.parent`的中间。然后`translate`内部百分比的参照物是自己，`translateX(-50%)`就是以`.child`自身宽度的 50%向左偏移从而使得元素居中。  \n优点：绝对定位脱离文档流，`.child`不会对其他元素产生影响。  \n缺点：`transform`是 CSS3 属性，不兼容 IE8。\n\n```\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n```\n\n4、 `flex` + `justify-content`  \n原理：设置`flex`以后子元素就变成了`flex-item`， `flex-item`默认情况下宽度是`auto`就是内容宽。除了对父元素设置`justify-content: center`， 对子元素设置`margin: 0 auto`也能使其居中，类似`table`元素。  \n优点：只需要设置父元素的样式。  \n缺点：`flex`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  display: flex;\n  justify-content: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  margin: 0 auto;\n}\n```\n\n&nbsp;\n\n### 垂直居中\n\n在父子元素高度都是未知的情况下实现垂直居中，难点在于理解`vertical-align`的使用场景。\n\n```\n<div class=\"parent\"</div>\n  <div class=\"child\"><div>\n</div>\n```\n\n1、 `table-cell` + `vertical-align`  \n原理：`vertical-align: middle`可以作用在`inline`元素、`inline-block`元素以及`table-cell`元素上。只有在`tabel-cell`元素中是用来设置单元格内容的对齐方式。当设置在行内元素上时，效果是设置这个元素相对于所在行基线的垂直对齐。题外话，如果想要和`text-align: center`实现文本水平居中一样实现文本的垂直居中，应该用`line-height`，将其高度设置成元素高度即可。  \n优点：兼容性很好。\n\n```\n.parent {\n  display: table-cell;\n  vertical-align: middle;\n}\n```\n\n2、 `absolute` + `transform`  \n原理：参照水平居中方案三。  \n优点：子元素不会干扰其他元素。  \n缺点：`transform`是 CSS3 属性，IE8 不兼容。而且当父容器未设置高度，即高度通过子元素撑开时，子元素设置`absolute`之后脱离文档流，父容器就会没有高度，以致影响后续布局。\n\n```\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n```\n\n3、 `flex` + `align-items`  \n原理：`flex-item`的`align-items`属性默认值是`strech`，子元素会被拉伸到和父容器一样高。除了设置父元素的`align-items: center`使子元素继承得以居中，还可以直接单独设置子元素的`align-self: center`达到垂直居中。  \n优点：只需要设置父容器样式。  \n缺点：`flex`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  display: flex;\n  align-items: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n}\n```\n\n&nbsp;\n\n### 水平垂直居中\n\n在父子元素宽度、高度都是未知的情况下实现水平、垂直居中，综合上述方法即可。\n\n```\n<div class=\"parent\"</div>\n  <div class=\"child\"><div>\n</div>\n```\n\n1、`inline-block` + `text-align` + `table-cell` + `vertical-align`  \n优点：兼容性很好。\n\n```\n.parent {\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n```\n\n2、`absolute` + `transform`\n优点：子元素不会干扰其他元素。  \n缺点：`transform`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n3、`flex` + `justify-content` + `align-items`  \n优点：只需要设置父元素样式。  \n缺点：`flex`是 CSS3 属性，IE8 不兼容。\n\n```\n.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n/* other solution 1 */\n.parent {\n  display: flex;\n  align-items: center;\n}\n.child {\n  margin: 0 auto;\n}\n\n/* other solution 2 */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n  margin: 0 auto;\n}\n```\n","slug":"layout1","published":1,"updated":"2018-04-08T14:35:31.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqxysl100009wfrezyjts29","content":"<p>本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。</p>\n<h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><p>在父子元素宽度都是未知的情况下实现水平居中，难点在于要先设置子元素的宽度变成内容宽，然后设置父元素或者子元素的样式使其居中。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&lt;/div&gt;\n  &lt;div class=&quot;child&quot;&gt;&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>inline-block</code> + <code>text-align</code><br>原理：<code>inline-block</code>元素的宽度是内容宽，<code>text-align</code>对<code>inline</code>元素以及<code>inline-block</code>元素都会起作用。<br>优点：兼容性很好。<br>缺点：<code>text-align: center</code>会被继承，<code>.child</code>里面有文字的话就会被居中。</p>\n<pre><code>.parent {\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n</code></pre><p>2、 <code>table</code> + <code>margin</code><br>原理：<code>block</code>元素定宽+<code>margin: 0 auto</code>可以实现水平居中。<code>table</code>元素表现上很像<code>block</code>元素，但是<code>table</code>元素的宽度也是内容宽。<br>优点：只需要设置子元素的样式，不用关心父元素，同时 IE8 以上浏览器兼容性很好。</p>\n<pre><code>.child {\n  display: table;\n  margin: 0 auto;\n}\n</code></pre><p>3、 <code>absolute</code> + <code>transform</code><br>原理：<code>absolute</code>元素默认没有宽度，宽度由内容决定。<code>left: 50%</code>是相对于<code>.parent</code>的 50%，<code>.child</code>的左边就会抵达<code>.parent</code>的中间。然后<code>translate</code>内部百分比的参照物是自己，<code>translateX(-50%)</code>就是以<code>.child</code>自身宽度的 50%向左偏移从而使得元素居中。<br>优点：绝对定位脱离文档流，<code>.child</code>不会对其他元素产生影响。<br>缺点：<code>transform</code>是 CSS3 属性，不兼容 IE8。</p>\n<pre><code>.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n</code></pre><p>4、 <code>flex</code> + <code>justify-content</code><br>原理：设置<code>flex</code>以后子元素就变成了<code>flex-item</code>， <code>flex-item</code>默认情况下宽度是<code>auto</code>就是内容宽。除了对父元素设置<code>justify-content: center</code>， 对子元素设置<code>margin: 0 auto</code>也能使其居中，类似<code>table</code>元素。<br>优点：只需要设置父元素的样式。<br>缺点：<code>flex</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  display: flex;\n  justify-content: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  margin: 0 auto;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3><p>在父子元素高度都是未知的情况下实现垂直居中，难点在于理解<code>vertical-align</code>的使用场景。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&lt;/div&gt;\n  &lt;div class=&quot;child&quot;&gt;&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>table-cell</code> + <code>vertical-align</code><br>原理：<code>vertical-align: middle</code>可以作用在<code>inline</code>元素、<code>inline-block</code>元素以及<code>table-cell</code>元素上。只有在<code>tabel-cell</code>元素中是用来设置单元格内容的对齐方式。当设置在行内元素上时，效果是设置这个元素相对于所在行基线的垂直对齐。题外话，如果想要和<code>text-align: center</code>实现文本水平居中一样实现文本的垂直居中，应该用<code>line-height</code>，将其高度设置成元素高度即可。<br>优点：兼容性很好。</p>\n<pre><code>.parent {\n  display: table-cell;\n  vertical-align: middle;\n}\n</code></pre><p>2、 <code>absolute</code> + <code>transform</code><br>原理：参照水平居中方案三。<br>优点：子元素不会干扰其他元素。<br>缺点：<code>transform</code>是 CSS3 属性，IE8 不兼容。而且当父容器未设置高度，即高度通过子元素撑开时，子元素设置<code>absolute</code>之后脱离文档流，父容器就会没有高度，以致影响后续布局。</p>\n<pre><code>.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n</code></pre><p>3、 <code>flex</code> + <code>align-items</code><br>原理：<code>flex-item</code>的<code>align-items</code>属性默认值是<code>strech</code>，子元素会被拉伸到和父容器一样高。除了设置父元素的<code>align-items: center</code>使子元素继承得以居中，还可以直接单独设置子元素的<code>align-self: center</code>达到垂直居中。<br>优点：只需要设置父容器样式。<br>缺点：<code>flex</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  display: flex;\n  align-items: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"水平垂直居中\"><a href=\"#水平垂直居中\" class=\"headerlink\" title=\"水平垂直居中\"></a>水平垂直居中</h3><p>在父子元素宽度、高度都是未知的情况下实现水平、垂直居中，综合上述方法即可。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&lt;/div&gt;\n  &lt;div class=&quot;child&quot;&gt;&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>1、<code>inline-block</code> + <code>text-align</code> + <code>table-cell</code> + <code>vertical-align</code><br>优点：兼容性很好。</p>\n<pre><code>.parent {\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n</code></pre><p>2、<code>absolute</code> + <code>transform</code><br>优点：子元素不会干扰其他元素。<br>缺点：<code>transform</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n</code></pre><p>3、<code>flex</code> + <code>justify-content</code> + <code>align-items</code><br>优点：只需要设置父元素样式。<br>缺点：<code>flex</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n/* other solution 1 */\n.parent {\n  display: flex;\n  align-items: center;\n}\n.child {\n  margin: 0 auto;\n}\n\n/* other solution 2 */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n  margin: 0 auto;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。</p>\n<h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><p>在父子元素宽度都是未知的情况下实现水平居中，难点在于要先设置子元素的宽度变成内容宽，然后设置父元素或者子元素的样式使其居中。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&lt;/div&gt;\n  &lt;div class=&quot;child&quot;&gt;&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>inline-block</code> + <code>text-align</code><br>原理：<code>inline-block</code>元素的宽度是内容宽，<code>text-align</code>对<code>inline</code>元素以及<code>inline-block</code>元素都会起作用。<br>优点：兼容性很好。<br>缺点：<code>text-align: center</code>会被继承，<code>.child</code>里面有文字的话就会被居中。</p>\n<pre><code>.parent {\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n</code></pre><p>2、 <code>table</code> + <code>margin</code><br>原理：<code>block</code>元素定宽+<code>margin: 0 auto</code>可以实现水平居中。<code>table</code>元素表现上很像<code>block</code>元素，但是<code>table</code>元素的宽度也是内容宽。<br>优点：只需要设置子元素的样式，不用关心父元素，同时 IE8 以上浏览器兼容性很好。</p>\n<pre><code>.child {\n  display: table;\n  margin: 0 auto;\n}\n</code></pre><p>3、 <code>absolute</code> + <code>transform</code><br>原理：<code>absolute</code>元素默认没有宽度，宽度由内容决定。<code>left: 50%</code>是相对于<code>.parent</code>的 50%，<code>.child</code>的左边就会抵达<code>.parent</code>的中间。然后<code>translate</code>内部百分比的参照物是自己，<code>translateX(-50%)</code>就是以<code>.child</code>自身宽度的 50%向左偏移从而使得元素居中。<br>优点：绝对定位脱离文档流，<code>.child</code>不会对其他元素产生影响。<br>缺点：<code>transform</code>是 CSS3 属性，不兼容 IE8。</p>\n<pre><code>.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n</code></pre><p>4、 <code>flex</code> + <code>justify-content</code><br>原理：设置<code>flex</code>以后子元素就变成了<code>flex-item</code>， <code>flex-item</code>默认情况下宽度是<code>auto</code>就是内容宽。除了对父元素设置<code>justify-content: center</code>， 对子元素设置<code>margin: 0 auto</code>也能使其居中，类似<code>table</code>元素。<br>优点：只需要设置父元素的样式。<br>缺点：<code>flex</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  display: flex;\n  justify-content: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  margin: 0 auto;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3><p>在父子元素高度都是未知的情况下实现垂直居中，难点在于理解<code>vertical-align</code>的使用场景。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&lt;/div&gt;\n  &lt;div class=&quot;child&quot;&gt;&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>table-cell</code> + <code>vertical-align</code><br>原理：<code>vertical-align: middle</code>可以作用在<code>inline</code>元素、<code>inline-block</code>元素以及<code>table-cell</code>元素上。只有在<code>tabel-cell</code>元素中是用来设置单元格内容的对齐方式。当设置在行内元素上时，效果是设置这个元素相对于所在行基线的垂直对齐。题外话，如果想要和<code>text-align: center</code>实现文本水平居中一样实现文本的垂直居中，应该用<code>line-height</code>，将其高度设置成元素高度即可。<br>优点：兼容性很好。</p>\n<pre><code>.parent {\n  display: table-cell;\n  vertical-align: middle;\n}\n</code></pre><p>2、 <code>absolute</code> + <code>transform</code><br>原理：参照水平居中方案三。<br>优点：子元素不会干扰其他元素。<br>缺点：<code>transform</code>是 CSS3 属性，IE8 不兼容。而且当父容器未设置高度，即高度通过子元素撑开时，子元素设置<code>absolute</code>之后脱离文档流，父容器就会没有高度，以致影响后续布局。</p>\n<pre><code>.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n</code></pre><p>3、 <code>flex</code> + <code>align-items</code><br>原理：<code>flex-item</code>的<code>align-items</code>属性默认值是<code>strech</code>，子元素会被拉伸到和父容器一样高。除了设置父元素的<code>align-items: center</code>使子元素继承得以居中，还可以直接单独设置子元素的<code>align-self: center</code>达到垂直居中。<br>优点：只需要设置父容器样式。<br>缺点：<code>flex</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  display: flex;\n  align-items: center;\n}\n\n/* another solution */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"水平垂直居中\"><a href=\"#水平垂直居中\" class=\"headerlink\" title=\"水平垂直居中\"></a>水平垂直居中</h3><p>在父子元素宽度、高度都是未知的情况下实现水平、垂直居中，综合上述方法即可。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&lt;/div&gt;\n  &lt;div class=&quot;child&quot;&gt;&lt;div&gt;\n&lt;/div&gt;\n</code></pre><p>1、<code>inline-block</code> + <code>text-align</code> + <code>table-cell</code> + <code>vertical-align</code><br>优点：兼容性很好。</p>\n<pre><code>.parent {\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n}\n.child {\n  display: inline-block;\n}\n</code></pre><p>2、<code>absolute</code> + <code>transform</code><br>优点：子元素不会干扰其他元素。<br>缺点：<code>transform</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n</code></pre><p>3、<code>flex</code> + <code>justify-content</code> + <code>align-items</code><br>优点：只需要设置父元素样式。<br>缺点：<code>flex</code>是 CSS3 属性，IE8 不兼容。</p>\n<pre><code>.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n/* other solution 1 */\n.parent {\n  display: flex;\n  align-items: center;\n}\n.child {\n  margin: 0 auto;\n}\n\n/* other solution 2 */\n.parent {\n  display: flex;\n}\n.child {\n  align-self: center;\n  margin: 0 auto;\n}\n</code></pre>"},{"title":"多列布局","date":"2017-07-07T14:36:17.000Z","_content":"\n本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。\n\n### 一列定宽一列自适应\n\n难点在于设置两行并列和自适应那栏的宽度处理。\n\n```\n<div class=\"parent\">\n  <div class=\"left\">\n    <p>left</p>\n  </div>\n  <div class=\"right\">\n    <p>right</p>\n  </div>\n</div>\n```\n\n1、 `float` + `margin`  \n原理：`float`会让元素脱离文档流，而其文本没有脱离，所以会形成环绕效果。`.right`的 120px 左边距，多出来的 20px 就是视觉上的间距。如果给`.left`设置`margin-right: 120px`，`.left`元素已经脱离文档流，设置外边距对还在文档流中的`.right`是无效的。同时因为其`float`元素的文本没有脱离文档流，最终效果就是对`.right`的内部文本产生类似`padding-left: 20px`的影响。  \n优点：非常简单。  \n缺点：`.right`内部文本`p`清除浮动以后，`p`会“掉下去”。\n\n```\n.left {\n  float: left; /* Or divs will align vertically */\n  width: 100px;\n}\n.right {\n  margin-left: 120px;\n}\n```\n\n2、 `float` + `margin` + `(fix)`  \n原理：开启 BFC 模式以后`.right`就会独立不受浮动的`.left`影响。使用`float: right`开启 BFC，`float`元素宽是内容宽，为了让右侧宽度自适应，就要外面新套一层`.right-fix`设置`width: 100%`，内部设置`margin-left: 120px`来保证`.right`的宽度是自适应的。但位置不够又导致`.right-fix`“掉下去”，所以使用`margin`负值又将它“提上来”。此时由于层级问题，`.right-fix`会盖住`.left`，导致`.left`无法被点击，最后要使用`position: relative`提高`.left`的层级。  \n优点：兼容性很好。  \n缺点：结构和样式比较复杂。\n\n```\n<div class=\"parent\">\n  <div class=\"left\">\n    <p>left1</p>\n  </div>\n  <div class=\"right-fix\">\n    <div class=\"right\">\n      <p>right1</p>\n    </div>\n  </div>\n</div>\n```\n\n```\n.left {\n  float: left;\n  width: 100px;\n  position: relative;\n}\n.right-fix {\n  float: right;\n  width: 100%;\n  margin-left: -100px;\n}\n.right {\n  margin-left: 120px;\n}\n```\n\n3、 `float` + `margin` + `calc`  \n原理：根据上一个例子的启发，使用`float: right`开启 BFC 模式，然后计算宽度使其自适应并正常排列。  \n优点：简单。  \n缺点：`calc()`是 CSS3 方法，不兼容 IE8。\n\n```\n.left {\n  float: left;\n  width: 100px;\n}\n.right {\n  float: right;\n  width: calc(100% - 120px);\n}\n```\n\n4、 `float` + `overflow`  \n原理：开启 BFC 的另一种方法，设置`overflow`除`visible`以外的参数。  \n优点：简单。\n\n```\n.left {\n  float: left;\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n```\n\n5、 `table`  \n原理：`display: table`宽度是内容宽，所以要设置宽度 100%。设置子元素`display: table-cell`，`.left`和`.right`就是水平排列的两个等分单元格。`table`特性是每列宽度之和等于整个表格宽度，所以设置`.left`宽度之后，`.right`一定是剩余宽度。单元格设置`margin`无效，故使用`padding`做间隔。由于是定宽处理，增加`table-layout: fixed`可以实现布局优先、加速渲染。  \n缺点：代码比较多。\n\n```\n.parent {\n  display: table;\n  width: 100%;\n  table-layout: fixed;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 100px;\n  padding-right: 20px;\n}\n```\n\n6、 `flex`  \n原理：设置`display: flex`，子元素变成`flex-item`水平排布，其宽度是内容宽。设置`flex: 1`就会获取剩余宽度。  \n缺点：flex 是 CSS3 属性，不兼容 IE8。而且性能有一定问题，只适合小范围布局。\n\n```\n.parent {\n  display: flex;\n}\n.left {\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n```\n\n7、 `grid`  \n原理：设置`grid-template-columns`分成水平左右两列，右列设置`auto`来自适应宽度。  \n优点：面向未来的前端布局解决方案。  \n缺点：兼容性比`flex`还差。\n\n```\n.parent {\n  display: grid;\n  grid-template-columns: 100px auto;\n  grid-column-gap: 20px;\n}\n```\n\n&nbsp;\n\n### 一列不定宽一列自适应\n\n基于上述一列定宽的思路，筛选去掉固定宽后，使用内容宽的，同时设置间隔不依赖于固定宽的布局解决方案。\n\n```\n<div class=\"parent\">\n  <div class=\"left\">\n    <p>left1</p>\n  </div>\n  <div class=\"right\">\n    <p>right1</p>\n  </div>\n</div>\n```\n\n1、 `float` + `overflow`  \n优点：简单、常用。\n\n```\n.left {\n  float: left;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n```\n\n2、 `table`  \n原理：定宽下`table-layout: fixed`布局优先的设置必须移除，默认`auto`内容优先。同时必须给左列设置最小宽度，然后靠内容撑开，否则左右单元格会均分宽度。\n\n```\n.parent {\n  display: table;\n  width: 100%;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 0.1%;\n  padding-right: 20px;\n}\n```\n\n3、 `flex`\n\n```\n.parent {\n  display: flex;\n}\n.left {\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n```\n","source":"_posts/layout2.md","raw":"---\ntitle: 多列布局\ndate: 2017-07-07 22:36:17\ncategories: CSS\ntags: [Layout, Interview]\n---\n\n本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。\n\n### 一列定宽一列自适应\n\n难点在于设置两行并列和自适应那栏的宽度处理。\n\n```\n<div class=\"parent\">\n  <div class=\"left\">\n    <p>left</p>\n  </div>\n  <div class=\"right\">\n    <p>right</p>\n  </div>\n</div>\n```\n\n1、 `float` + `margin`  \n原理：`float`会让元素脱离文档流，而其文本没有脱离，所以会形成环绕效果。`.right`的 120px 左边距，多出来的 20px 就是视觉上的间距。如果给`.left`设置`margin-right: 120px`，`.left`元素已经脱离文档流，设置外边距对还在文档流中的`.right`是无效的。同时因为其`float`元素的文本没有脱离文档流，最终效果就是对`.right`的内部文本产生类似`padding-left: 20px`的影响。  \n优点：非常简单。  \n缺点：`.right`内部文本`p`清除浮动以后，`p`会“掉下去”。\n\n```\n.left {\n  float: left; /* Or divs will align vertically */\n  width: 100px;\n}\n.right {\n  margin-left: 120px;\n}\n```\n\n2、 `float` + `margin` + `(fix)`  \n原理：开启 BFC 模式以后`.right`就会独立不受浮动的`.left`影响。使用`float: right`开启 BFC，`float`元素宽是内容宽，为了让右侧宽度自适应，就要外面新套一层`.right-fix`设置`width: 100%`，内部设置`margin-left: 120px`来保证`.right`的宽度是自适应的。但位置不够又导致`.right-fix`“掉下去”，所以使用`margin`负值又将它“提上来”。此时由于层级问题，`.right-fix`会盖住`.left`，导致`.left`无法被点击，最后要使用`position: relative`提高`.left`的层级。  \n优点：兼容性很好。  \n缺点：结构和样式比较复杂。\n\n```\n<div class=\"parent\">\n  <div class=\"left\">\n    <p>left1</p>\n  </div>\n  <div class=\"right-fix\">\n    <div class=\"right\">\n      <p>right1</p>\n    </div>\n  </div>\n</div>\n```\n\n```\n.left {\n  float: left;\n  width: 100px;\n  position: relative;\n}\n.right-fix {\n  float: right;\n  width: 100%;\n  margin-left: -100px;\n}\n.right {\n  margin-left: 120px;\n}\n```\n\n3、 `float` + `margin` + `calc`  \n原理：根据上一个例子的启发，使用`float: right`开启 BFC 模式，然后计算宽度使其自适应并正常排列。  \n优点：简单。  \n缺点：`calc()`是 CSS3 方法，不兼容 IE8。\n\n```\n.left {\n  float: left;\n  width: 100px;\n}\n.right {\n  float: right;\n  width: calc(100% - 120px);\n}\n```\n\n4、 `float` + `overflow`  \n原理：开启 BFC 的另一种方法，设置`overflow`除`visible`以外的参数。  \n优点：简单。\n\n```\n.left {\n  float: left;\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n```\n\n5、 `table`  \n原理：`display: table`宽度是内容宽，所以要设置宽度 100%。设置子元素`display: table-cell`，`.left`和`.right`就是水平排列的两个等分单元格。`table`特性是每列宽度之和等于整个表格宽度，所以设置`.left`宽度之后，`.right`一定是剩余宽度。单元格设置`margin`无效，故使用`padding`做间隔。由于是定宽处理，增加`table-layout: fixed`可以实现布局优先、加速渲染。  \n缺点：代码比较多。\n\n```\n.parent {\n  display: table;\n  width: 100%;\n  table-layout: fixed;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 100px;\n  padding-right: 20px;\n}\n```\n\n6、 `flex`  \n原理：设置`display: flex`，子元素变成`flex-item`水平排布，其宽度是内容宽。设置`flex: 1`就会获取剩余宽度。  \n缺点：flex 是 CSS3 属性，不兼容 IE8。而且性能有一定问题，只适合小范围布局。\n\n```\n.parent {\n  display: flex;\n}\n.left {\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n```\n\n7、 `grid`  \n原理：设置`grid-template-columns`分成水平左右两列，右列设置`auto`来自适应宽度。  \n优点：面向未来的前端布局解决方案。  \n缺点：兼容性比`flex`还差。\n\n```\n.parent {\n  display: grid;\n  grid-template-columns: 100px auto;\n  grid-column-gap: 20px;\n}\n```\n\n&nbsp;\n\n### 一列不定宽一列自适应\n\n基于上述一列定宽的思路，筛选去掉固定宽后，使用内容宽的，同时设置间隔不依赖于固定宽的布局解决方案。\n\n```\n<div class=\"parent\">\n  <div class=\"left\">\n    <p>left1</p>\n  </div>\n  <div class=\"right\">\n    <p>right1</p>\n  </div>\n</div>\n```\n\n1、 `float` + `overflow`  \n优点：简单、常用。\n\n```\n.left {\n  float: left;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n```\n\n2、 `table`  \n原理：定宽下`table-layout: fixed`布局优先的设置必须移除，默认`auto`内容优先。同时必须给左列设置最小宽度，然后靠内容撑开，否则左右单元格会均分宽度。\n\n```\n.parent {\n  display: table;\n  width: 100%;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 0.1%;\n  padding-right: 20px;\n}\n```\n\n3、 `flex`\n\n```\n.parent {\n  display: flex;\n}\n.left {\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n```\n","slug":"layout2","published":1,"updated":"2018-04-08T14:40:00.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqxysl600029wfrxywhiy3r","content":"<p>本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。</p>\n<h3 id=\"一列定宽一列自适应\"><a href=\"#一列定宽一列自适应\" class=\"headerlink\" title=\"一列定宽一列自适应\"></a>一列定宽一列自适应</h3><p>难点在于设置两行并列和自适应那栏的宽度处理。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;left&quot;&gt;\n    &lt;p&gt;left&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;\n    &lt;p&gt;right&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>float</code> + <code>margin</code><br>原理：<code>float</code>会让元素脱离文档流，而其文本没有脱离，所以会形成环绕效果。<code>.right</code>的 120px 左边距，多出来的 20px 就是视觉上的间距。如果给<code>.left</code>设置<code>margin-right: 120px</code>，<code>.left</code>元素已经脱离文档流，设置外边距对还在文档流中的<code>.right</code>是无效的。同时因为其<code>float</code>元素的文本没有脱离文档流，最终效果就是对<code>.right</code>的内部文本产生类似<code>padding-left: 20px</code>的影响。<br>优点：非常简单。<br>缺点：<code>.right</code>内部文本<code>p</code>清除浮动以后，<code>p</code>会“掉下去”。</p>\n<pre><code>.left {\n  float: left; /* Or divs will align vertically */\n  width: 100px;\n}\n.right {\n  margin-left: 120px;\n}\n</code></pre><p>2、 <code>float</code> + <code>margin</code> + <code>(fix)</code><br>原理：开启 BFC 模式以后<code>.right</code>就会独立不受浮动的<code>.left</code>影响。使用<code>float: right</code>开启 BFC，<code>float</code>元素宽是内容宽，为了让右侧宽度自适应，就要外面新套一层<code>.right-fix</code>设置<code>width: 100%</code>，内部设置<code>margin-left: 120px</code>来保证<code>.right</code>的宽度是自适应的。但位置不够又导致<code>.right-fix</code>“掉下去”，所以使用<code>margin</code>负值又将它“提上来”。此时由于层级问题，<code>.right-fix</code>会盖住<code>.left</code>，导致<code>.left</code>无法被点击，最后要使用<code>position: relative</code>提高<code>.left</code>的层级。<br>优点：兼容性很好。<br>缺点：结构和样式比较复杂。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;left&quot;&gt;\n    &lt;p&gt;left1&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;right-fix&quot;&gt;\n    &lt;div class=&quot;right&quot;&gt;\n      &lt;p&gt;right1&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><pre><code>.left {\n  float: left;\n  width: 100px;\n  position: relative;\n}\n.right-fix {\n  float: right;\n  width: 100%;\n  margin-left: -100px;\n}\n.right {\n  margin-left: 120px;\n}\n</code></pre><p>3、 <code>float</code> + <code>margin</code> + <code>calc</code><br>原理：根据上一个例子的启发，使用<code>float: right</code>开启 BFC 模式，然后计算宽度使其自适应并正常排列。<br>优点：简单。<br>缺点：<code>calc()</code>是 CSS3 方法，不兼容 IE8。</p>\n<pre><code>.left {\n  float: left;\n  width: 100px;\n}\n.right {\n  float: right;\n  width: calc(100% - 120px);\n}\n</code></pre><p>4、 <code>float</code> + <code>overflow</code><br>原理：开启 BFC 的另一种方法，设置<code>overflow</code>除<code>visible</code>以外的参数。<br>优点：简单。</p>\n<pre><code>.left {\n  float: left;\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n</code></pre><p>5、 <code>table</code><br>原理：<code>display: table</code>宽度是内容宽，所以要设置宽度 100%。设置子元素<code>display: table-cell</code>，<code>.left</code>和<code>.right</code>就是水平排列的两个等分单元格。<code>table</code>特性是每列宽度之和等于整个表格宽度，所以设置<code>.left</code>宽度之后，<code>.right</code>一定是剩余宽度。单元格设置<code>margin</code>无效，故使用<code>padding</code>做间隔。由于是定宽处理，增加<code>table-layout: fixed</code>可以实现布局优先、加速渲染。<br>缺点：代码比较多。</p>\n<pre><code>.parent {\n  display: table;\n  width: 100%;\n  table-layout: fixed;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 100px;\n  padding-right: 20px;\n}\n</code></pre><p>6、 <code>flex</code><br>原理：设置<code>display: flex</code>，子元素变成<code>flex-item</code>水平排布，其宽度是内容宽。设置<code>flex: 1</code>就会获取剩余宽度。<br>缺点：flex 是 CSS3 属性，不兼容 IE8。而且性能有一定问题，只适合小范围布局。</p>\n<pre><code>.parent {\n  display: flex;\n}\n.left {\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n</code></pre><p>7、 <code>grid</code><br>原理：设置<code>grid-template-columns</code>分成水平左右两列，右列设置<code>auto</code>来自适应宽度。<br>优点：面向未来的前端布局解决方案。<br>缺点：兼容性比<code>flex</code>还差。</p>\n<pre><code>.parent {\n  display: grid;\n  grid-template-columns: 100px auto;\n  grid-column-gap: 20px;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"一列不定宽一列自适应\"><a href=\"#一列不定宽一列自适应\" class=\"headerlink\" title=\"一列不定宽一列自适应\"></a>一列不定宽一列自适应</h3><p>基于上述一列定宽的思路，筛选去掉固定宽后，使用内容宽的，同时设置间隔不依赖于固定宽的布局解决方案。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;left&quot;&gt;\n    &lt;p&gt;left1&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;\n    &lt;p&gt;right1&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>float</code> + <code>overflow</code><br>优点：简单、常用。</p>\n<pre><code>.left {\n  float: left;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n</code></pre><p>2、 <code>table</code><br>原理：定宽下<code>table-layout: fixed</code>布局优先的设置必须移除，默认<code>auto</code>内容优先。同时必须给左列设置最小宽度，然后靠内容撑开，否则左右单元格会均分宽度。</p>\n<pre><code>.parent {\n  display: table;\n  width: 100%;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 0.1%;\n  padding-right: 20px;\n}\n</code></pre><p>3、 <code>flex</code></p>\n<pre><code>.parent {\n  display: flex;\n}\n.left {\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本篇内容总结于网易前端微专业的页面架构，并进行了相应扩展。</p>\n<h3 id=\"一列定宽一列自适应\"><a href=\"#一列定宽一列自适应\" class=\"headerlink\" title=\"一列定宽一列自适应\"></a>一列定宽一列自适应</h3><p>难点在于设置两行并列和自适应那栏的宽度处理。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;left&quot;&gt;\n    &lt;p&gt;left&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;\n    &lt;p&gt;right&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>float</code> + <code>margin</code><br>原理：<code>float</code>会让元素脱离文档流，而其文本没有脱离，所以会形成环绕效果。<code>.right</code>的 120px 左边距，多出来的 20px 就是视觉上的间距。如果给<code>.left</code>设置<code>margin-right: 120px</code>，<code>.left</code>元素已经脱离文档流，设置外边距对还在文档流中的<code>.right</code>是无效的。同时因为其<code>float</code>元素的文本没有脱离文档流，最终效果就是对<code>.right</code>的内部文本产生类似<code>padding-left: 20px</code>的影响。<br>优点：非常简单。<br>缺点：<code>.right</code>内部文本<code>p</code>清除浮动以后，<code>p</code>会“掉下去”。</p>\n<pre><code>.left {\n  float: left; /* Or divs will align vertically */\n  width: 100px;\n}\n.right {\n  margin-left: 120px;\n}\n</code></pre><p>2、 <code>float</code> + <code>margin</code> + <code>(fix)</code><br>原理：开启 BFC 模式以后<code>.right</code>就会独立不受浮动的<code>.left</code>影响。使用<code>float: right</code>开启 BFC，<code>float</code>元素宽是内容宽，为了让右侧宽度自适应，就要外面新套一层<code>.right-fix</code>设置<code>width: 100%</code>，内部设置<code>margin-left: 120px</code>来保证<code>.right</code>的宽度是自适应的。但位置不够又导致<code>.right-fix</code>“掉下去”，所以使用<code>margin</code>负值又将它“提上来”。此时由于层级问题，<code>.right-fix</code>会盖住<code>.left</code>，导致<code>.left</code>无法被点击，最后要使用<code>position: relative</code>提高<code>.left</code>的层级。<br>优点：兼容性很好。<br>缺点：结构和样式比较复杂。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;left&quot;&gt;\n    &lt;p&gt;left1&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;right-fix&quot;&gt;\n    &lt;div class=&quot;right&quot;&gt;\n      &lt;p&gt;right1&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><pre><code>.left {\n  float: left;\n  width: 100px;\n  position: relative;\n}\n.right-fix {\n  float: right;\n  width: 100%;\n  margin-left: -100px;\n}\n.right {\n  margin-left: 120px;\n}\n</code></pre><p>3、 <code>float</code> + <code>margin</code> + <code>calc</code><br>原理：根据上一个例子的启发，使用<code>float: right</code>开启 BFC 模式，然后计算宽度使其自适应并正常排列。<br>优点：简单。<br>缺点：<code>calc()</code>是 CSS3 方法，不兼容 IE8。</p>\n<pre><code>.left {\n  float: left;\n  width: 100px;\n}\n.right {\n  float: right;\n  width: calc(100% - 120px);\n}\n</code></pre><p>4、 <code>float</code> + <code>overflow</code><br>原理：开启 BFC 的另一种方法，设置<code>overflow</code>除<code>visible</code>以外的参数。<br>优点：简单。</p>\n<pre><code>.left {\n  float: left;\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n</code></pre><p>5、 <code>table</code><br>原理：<code>display: table</code>宽度是内容宽，所以要设置宽度 100%。设置子元素<code>display: table-cell</code>，<code>.left</code>和<code>.right</code>就是水平排列的两个等分单元格。<code>table</code>特性是每列宽度之和等于整个表格宽度，所以设置<code>.left</code>宽度之后，<code>.right</code>一定是剩余宽度。单元格设置<code>margin</code>无效，故使用<code>padding</code>做间隔。由于是定宽处理，增加<code>table-layout: fixed</code>可以实现布局优先、加速渲染。<br>缺点：代码比较多。</p>\n<pre><code>.parent {\n  display: table;\n  width: 100%;\n  table-layout: fixed;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 100px;\n  padding-right: 20px;\n}\n</code></pre><p>6、 <code>flex</code><br>原理：设置<code>display: flex</code>，子元素变成<code>flex-item</code>水平排布，其宽度是内容宽。设置<code>flex: 1</code>就会获取剩余宽度。<br>缺点：flex 是 CSS3 属性，不兼容 IE8。而且性能有一定问题，只适合小范围布局。</p>\n<pre><code>.parent {\n  display: flex;\n}\n.left {\n  width: 100px;\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n</code></pre><p>7、 <code>grid</code><br>原理：设置<code>grid-template-columns</code>分成水平左右两列，右列设置<code>auto</code>来自适应宽度。<br>优点：面向未来的前端布局解决方案。<br>缺点：兼容性比<code>flex</code>还差。</p>\n<pre><code>.parent {\n  display: grid;\n  grid-template-columns: 100px auto;\n  grid-column-gap: 20px;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"一列不定宽一列自适应\"><a href=\"#一列不定宽一列自适应\" class=\"headerlink\" title=\"一列不定宽一列自适应\"></a>一列不定宽一列自适应</h3><p>基于上述一列定宽的思路，筛选去掉固定宽后，使用内容宽的，同时设置间隔不依赖于固定宽的布局解决方案。</p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n  &lt;div class=&quot;left&quot;&gt;\n    &lt;p&gt;left1&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;right&quot;&gt;\n    &lt;p&gt;right1&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>1、 <code>float</code> + <code>overflow</code><br>优点：简单、常用。</p>\n<pre><code>.left {\n  float: left;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n}\n</code></pre><p>2、 <code>table</code><br>原理：定宽下<code>table-layout: fixed</code>布局优先的设置必须移除，默认<code>auto</code>内容优先。同时必须给左列设置最小宽度，然后靠内容撑开，否则左右单元格会均分宽度。</p>\n<pre><code>.parent {\n  display: table;\n  width: 100%;\n}\n.left, .right {\n  display: table-cell;\n}\n.left {\n  width: 0.1%;\n  padding-right: 20px;\n}\n</code></pre><p>3、 <code>flex</code></p>\n<pre><code>.parent {\n  display: flex;\n}\n.left {\n  margin-right: 20px;\n}\n.right {\n  flex: 1;\n}\n</code></pre>"},{"title":"继承","date":"2017-02-25T14:28:49.000Z","_content":"\n本篇内容总结于慕课网的前端跳槽面试必备技巧，并进行了相应扩展。只有彻底明白[new](http://frontendsophie.com/javascript/2017/02/22/oop1.html)的工作原理，才能更好的理解继承。\n\n### 构造函数实现继承\n\n原理：使用`call()`或者`apply()`将父级构造函数的`this`指向子构造函数，相当于将父类的属性复制到子类中。  \n缺点：父构造函数的原型对象上的属性和方法没有被继承。\n\n```\nfunction Parent1() {\n  this.name = 'parent1';\n}\nfunction Child1() {\n  Parent1.call(this);\n  this.type = 'child1';\n}\n```\n\n&nbsp;\n\n### 原型链实现继承\n\n原理：通过`new`使得`Child2.prototype.__proto__`指向`Parent2.prototype`从而形成原型链，可以向上查找父构造函数原型对象上的属性和方法。  \n缺点：`s1.__proto__`和`s2.__proto__`都指向一个原型对象`Child2.prototype`，共用一个属性`play`，导致实例没有被隔离，会互相影响。\n\n```\nfunction Parent2() {\n  this.play = [1, 2, 3];\n}\nfunction Child2() {}\nChild2.prototype = new Parent2();\n\nvar s1 = new child2();\ns1.play.push(4);\nvar s2 = new child2();\nconsole.log(s1.play); // [1, 2, 3, 4]\nconsole.log(s2.play); // [1, 2, 3, 4]\nconsole.log(Child2.prototype.play); // [1, 2, 3, 4]\n```\n\n&nbsp;\n\n### 组合继承\n\n原理：结合构造函数和原型链的优点。  \n缺点：父级构造函数执行了两次，`call()`已经复制了一份父类的属性，`Child3.prototype`上没必要再复制一次。而且`new`的时候，构造函数动态传参也很尴尬。\n\n```\nfunction Parent3() {\n  this.name = 'parent3';\n  this.play = [1, 2, 3];\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = 'child3';\n}\nChild3.prototype = new Parent3();\n```\n\n&nbsp;\n\n### 组合继承的优化 1\n\n原理：直接将子类的`prototype`指向父类的`prototype`，绕过`new`中的隐藏`call()`调用。  \n缺点：实例无法判断构造函数是哪个，由于子类和父类共用一个原型对象，子类原型对象的`constructor`就是父类原型对象的`constructor`，父类原型对象的`constructor`指向自己。一旦修改子类原型对象的`constructor`, 父类的也会被修改。\n\n```\nfunction Parent4() {\n  this.name = 'parent4';\n  this.play = [1, 2, 3];\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = 'child4';\n}\nChild4.prototype = Parent4.prototype;\n\nvar s4 = new Child4();\ns4 instanceof Child4; // true\ns4 instanceof Parent4; // true\ns4.constructor === Parent4; // true\n```\n\n&nbsp;\n\n### 组合继承的优化 2\n\n原理：`Object.create()`新建一个对象并将它的`__proto__`指向传入的参数，也就是`Child5.prototype.__proto__`指向`Parent5.prototype`。这样子类原型对象和父类原型就不是同一个对象，但又形成了原型链得以继承。\n\n```\nfunction Parent5() {\n  this.name = 'parent5';\n  this.play = [1, 2, 3];\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = 'child5';\n}\nChild5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n```\n\n`Object.create()`很像没有隐式调用`call()`的`new`，它的兼容写法是：\n\n```\nif (!Object.create) {\n  Object.create = function(proto) {\n    var F = function(){};\n    F.prototype = proto;\n    return new F();\n  }\n}\n```\n","source":"_posts/oop2.md","raw":"---\ntitle: 继承\ndate: 2017-02-25 22:28:49\ncategories: JavaScript\ntags: [OOP, Interview]\n---\n\n本篇内容总结于慕课网的前端跳槽面试必备技巧，并进行了相应扩展。只有彻底明白[new](http://frontendsophie.com/javascript/2017/02/22/oop1.html)的工作原理，才能更好的理解继承。\n\n### 构造函数实现继承\n\n原理：使用`call()`或者`apply()`将父级构造函数的`this`指向子构造函数，相当于将父类的属性复制到子类中。  \n缺点：父构造函数的原型对象上的属性和方法没有被继承。\n\n```\nfunction Parent1() {\n  this.name = 'parent1';\n}\nfunction Child1() {\n  Parent1.call(this);\n  this.type = 'child1';\n}\n```\n\n&nbsp;\n\n### 原型链实现继承\n\n原理：通过`new`使得`Child2.prototype.__proto__`指向`Parent2.prototype`从而形成原型链，可以向上查找父构造函数原型对象上的属性和方法。  \n缺点：`s1.__proto__`和`s2.__proto__`都指向一个原型对象`Child2.prototype`，共用一个属性`play`，导致实例没有被隔离，会互相影响。\n\n```\nfunction Parent2() {\n  this.play = [1, 2, 3];\n}\nfunction Child2() {}\nChild2.prototype = new Parent2();\n\nvar s1 = new child2();\ns1.play.push(4);\nvar s2 = new child2();\nconsole.log(s1.play); // [1, 2, 3, 4]\nconsole.log(s2.play); // [1, 2, 3, 4]\nconsole.log(Child2.prototype.play); // [1, 2, 3, 4]\n```\n\n&nbsp;\n\n### 组合继承\n\n原理：结合构造函数和原型链的优点。  \n缺点：父级构造函数执行了两次，`call()`已经复制了一份父类的属性，`Child3.prototype`上没必要再复制一次。而且`new`的时候，构造函数动态传参也很尴尬。\n\n```\nfunction Parent3() {\n  this.name = 'parent3';\n  this.play = [1, 2, 3];\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = 'child3';\n}\nChild3.prototype = new Parent3();\n```\n\n&nbsp;\n\n### 组合继承的优化 1\n\n原理：直接将子类的`prototype`指向父类的`prototype`，绕过`new`中的隐藏`call()`调用。  \n缺点：实例无法判断构造函数是哪个，由于子类和父类共用一个原型对象，子类原型对象的`constructor`就是父类原型对象的`constructor`，父类原型对象的`constructor`指向自己。一旦修改子类原型对象的`constructor`, 父类的也会被修改。\n\n```\nfunction Parent4() {\n  this.name = 'parent4';\n  this.play = [1, 2, 3];\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = 'child4';\n}\nChild4.prototype = Parent4.prototype;\n\nvar s4 = new Child4();\ns4 instanceof Child4; // true\ns4 instanceof Parent4; // true\ns4.constructor === Parent4; // true\n```\n\n&nbsp;\n\n### 组合继承的优化 2\n\n原理：`Object.create()`新建一个对象并将它的`__proto__`指向传入的参数，也就是`Child5.prototype.__proto__`指向`Parent5.prototype`。这样子类原型对象和父类原型就不是同一个对象，但又形成了原型链得以继承。\n\n```\nfunction Parent5() {\n  this.name = 'parent5';\n  this.play = [1, 2, 3];\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = 'child5';\n}\nChild5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n```\n\n`Object.create()`很像没有隐式调用`call()`的`new`，它的兼容写法是：\n\n```\nif (!Object.create) {\n  Object.create = function(proto) {\n    var F = function(){};\n    F.prototype = proto;\n    return new F();\n  }\n}\n```\n","slug":"oop2","published":1,"updated":"2018-04-08T14:31:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqxysla00069wfr18xc4rth","content":"<p>本篇内容总结于慕课网的前端跳槽面试必备技巧，并进行了相应扩展。只有彻底明白<a href=\"http://frontendsophie.com/javascript/2017/02/22/oop1.html\" target=\"_blank\" rel=\"noopener\">new</a>的工作原理，才能更好的理解继承。</p>\n<h3 id=\"构造函数实现继承\"><a href=\"#构造函数实现继承\" class=\"headerlink\" title=\"构造函数实现继承\"></a>构造函数实现继承</h3><p>原理：使用<code>call()</code>或者<code>apply()</code>将父级构造函数的<code>this</code>指向子构造函数，相当于将父类的属性复制到子类中。<br>缺点：父构造函数的原型对象上的属性和方法没有被继承。</p>\n<pre><code>function Parent1() {\n  this.name = &#39;parent1&#39;;\n}\nfunction Child1() {\n  Parent1.call(this);\n  this.type = &#39;child1&#39;;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"原型链实现继承\"><a href=\"#原型链实现继承\" class=\"headerlink\" title=\"原型链实现继承\"></a>原型链实现继承</h3><p>原理：通过<code>new</code>使得<code>Child2.prototype.__proto__</code>指向<code>Parent2.prototype</code>从而形成原型链，可以向上查找父构造函数原型对象上的属性和方法。<br>缺点：<code>s1.__proto__</code>和<code>s2.__proto__</code>都指向一个原型对象<code>Child2.prototype</code>，共用一个属性<code>play</code>，导致实例没有被隔离，会互相影响。</p>\n<pre><code>function Parent2() {\n  this.play = [1, 2, 3];\n}\nfunction Child2() {}\nChild2.prototype = new Parent2();\n\nvar s1 = new child2();\ns1.play.push(4);\nvar s2 = new child2();\nconsole.log(s1.play); // [1, 2, 3, 4]\nconsole.log(s2.play); // [1, 2, 3, 4]\nconsole.log(Child2.prototype.play); // [1, 2, 3, 4]\n</code></pre><p>&nbsp;</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>原理：结合构造函数和原型链的优点。<br>缺点：父级构造函数执行了两次，<code>call()</code>已经复制了一份父类的属性，<code>Child3.prototype</code>上没必要再复制一次。而且<code>new</code>的时候，构造函数动态传参也很尴尬。</p>\n<pre><code>function Parent3() {\n  this.name = &#39;parent3&#39;;\n  this.play = [1, 2, 3];\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = &#39;child3&#39;;\n}\nChild3.prototype = new Parent3();\n</code></pre><p>&nbsp;</p>\n<h3 id=\"组合继承的优化-1\"><a href=\"#组合继承的优化-1\" class=\"headerlink\" title=\"组合继承的优化 1\"></a>组合继承的优化 1</h3><p>原理：直接将子类的<code>prototype</code>指向父类的<code>prototype</code>，绕过<code>new</code>中的隐藏<code>call()</code>调用。<br>缺点：实例无法判断构造函数是哪个，由于子类和父类共用一个原型对象，子类原型对象的<code>constructor</code>就是父类原型对象的<code>constructor</code>，父类原型对象的<code>constructor</code>指向自己。一旦修改子类原型对象的<code>constructor</code>, 父类的也会被修改。</p>\n<pre><code>function Parent4() {\n  this.name = &#39;parent4&#39;;\n  this.play = [1, 2, 3];\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = &#39;child4&#39;;\n}\nChild4.prototype = Parent4.prototype;\n\nvar s4 = new Child4();\ns4 instanceof Child4; // true\ns4 instanceof Parent4; // true\ns4.constructor === Parent4; // true\n</code></pre><p>&nbsp;</p>\n<h3 id=\"组合继承的优化-2\"><a href=\"#组合继承的优化-2\" class=\"headerlink\" title=\"组合继承的优化 2\"></a>组合继承的优化 2</h3><p>原理：<code>Object.create()</code>新建一个对象并将它的<code>__proto__</code>指向传入的参数，也就是<code>Child5.prototype.__proto__</code>指向<code>Parent5.prototype</code>。这样子类原型对象和父类原型就不是同一个对象，但又形成了原型链得以继承。</p>\n<pre><code>function Parent5() {\n  this.name = &#39;parent5&#39;;\n  this.play = [1, 2, 3];\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = &#39;child5&#39;;\n}\nChild5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n</code></pre><p><code>Object.create()</code>很像没有隐式调用<code>call()</code>的<code>new</code>，它的兼容写法是：</p>\n<pre><code>if (!Object.create) {\n  Object.create = function(proto) {\n    var F = function(){};\n    F.prototype = proto;\n    return new F();\n  }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本篇内容总结于慕课网的前端跳槽面试必备技巧，并进行了相应扩展。只有彻底明白<a href=\"http://frontendsophie.com/javascript/2017/02/22/oop1.html\" target=\"_blank\" rel=\"noopener\">new</a>的工作原理，才能更好的理解继承。</p>\n<h3 id=\"构造函数实现继承\"><a href=\"#构造函数实现继承\" class=\"headerlink\" title=\"构造函数实现继承\"></a>构造函数实现继承</h3><p>原理：使用<code>call()</code>或者<code>apply()</code>将父级构造函数的<code>this</code>指向子构造函数，相当于将父类的属性复制到子类中。<br>缺点：父构造函数的原型对象上的属性和方法没有被继承。</p>\n<pre><code>function Parent1() {\n  this.name = &#39;parent1&#39;;\n}\nfunction Child1() {\n  Parent1.call(this);\n  this.type = &#39;child1&#39;;\n}\n</code></pre><p>&nbsp;</p>\n<h3 id=\"原型链实现继承\"><a href=\"#原型链实现继承\" class=\"headerlink\" title=\"原型链实现继承\"></a>原型链实现继承</h3><p>原理：通过<code>new</code>使得<code>Child2.prototype.__proto__</code>指向<code>Parent2.prototype</code>从而形成原型链，可以向上查找父构造函数原型对象上的属性和方法。<br>缺点：<code>s1.__proto__</code>和<code>s2.__proto__</code>都指向一个原型对象<code>Child2.prototype</code>，共用一个属性<code>play</code>，导致实例没有被隔离，会互相影响。</p>\n<pre><code>function Parent2() {\n  this.play = [1, 2, 3];\n}\nfunction Child2() {}\nChild2.prototype = new Parent2();\n\nvar s1 = new child2();\ns1.play.push(4);\nvar s2 = new child2();\nconsole.log(s1.play); // [1, 2, 3, 4]\nconsole.log(s2.play); // [1, 2, 3, 4]\nconsole.log(Child2.prototype.play); // [1, 2, 3, 4]\n</code></pre><p>&nbsp;</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>原理：结合构造函数和原型链的优点。<br>缺点：父级构造函数执行了两次，<code>call()</code>已经复制了一份父类的属性，<code>Child3.prototype</code>上没必要再复制一次。而且<code>new</code>的时候，构造函数动态传参也很尴尬。</p>\n<pre><code>function Parent3() {\n  this.name = &#39;parent3&#39;;\n  this.play = [1, 2, 3];\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = &#39;child3&#39;;\n}\nChild3.prototype = new Parent3();\n</code></pre><p>&nbsp;</p>\n<h3 id=\"组合继承的优化-1\"><a href=\"#组合继承的优化-1\" class=\"headerlink\" title=\"组合继承的优化 1\"></a>组合继承的优化 1</h3><p>原理：直接将子类的<code>prototype</code>指向父类的<code>prototype</code>，绕过<code>new</code>中的隐藏<code>call()</code>调用。<br>缺点：实例无法判断构造函数是哪个，由于子类和父类共用一个原型对象，子类原型对象的<code>constructor</code>就是父类原型对象的<code>constructor</code>，父类原型对象的<code>constructor</code>指向自己。一旦修改子类原型对象的<code>constructor</code>, 父类的也会被修改。</p>\n<pre><code>function Parent4() {\n  this.name = &#39;parent4&#39;;\n  this.play = [1, 2, 3];\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = &#39;child4&#39;;\n}\nChild4.prototype = Parent4.prototype;\n\nvar s4 = new Child4();\ns4 instanceof Child4; // true\ns4 instanceof Parent4; // true\ns4.constructor === Parent4; // true\n</code></pre><p>&nbsp;</p>\n<h3 id=\"组合继承的优化-2\"><a href=\"#组合继承的优化-2\" class=\"headerlink\" title=\"组合继承的优化 2\"></a>组合继承的优化 2</h3><p>原理：<code>Object.create()</code>新建一个对象并将它的<code>__proto__</code>指向传入的参数，也就是<code>Child5.prototype.__proto__</code>指向<code>Parent5.prototype</code>。这样子类原型对象和父类原型就不是同一个对象，但又形成了原型链得以继承。</p>\n<pre><code>function Parent5() {\n  this.name = &#39;parent5&#39;;\n  this.play = [1, 2, 3];\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = &#39;child5&#39;;\n}\nChild5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n</code></pre><p><code>Object.create()</code>很像没有隐式调用<code>call()</code>的<code>new</code>，它的兼容写法是：</p>\n<pre><code>if (!Object.create) {\n  Object.create = function(proto) {\n    var F = function(){};\n    F.prototype = proto;\n    return new F();\n  }\n}\n</code></pre>"},{"title":"原型与new","date":"2017-02-22T09:51:47.000Z","_content":"\n### `prototype`\n\n无论什么时候，只要创建了一个新函数，该函数就会创建一个`prototype`属性，指向这个函数的原型对象。这个原型对象里默认有一个属性：`constructor`，指向当前这个函数。\n\n```\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.constructor === Person; // true\n```\n\n&nbsp;\n\n### `__proto__`\n\n每个对象都有一个属性`__proto__`，它的指向取决于对象的创建方式，一般指向自身构造函数的原型对象（除了`Object.create()`）。本质是标准属性`[[Prototype]]`，由于`[[Prototype]]`不可见，Firefox、Safari、Chrome 浏览器实现了`__proto__`来访问。  \n实例化一个构造函数之后得到的实例化对象，它的`__proto__`属性就指向这个构造函数的`prototype`。\n\n```\nvar sophie = new Person('sophie');\nsophie.__proto__ === Person.prototype; // true\n```\n\n这个构造函数的原型对象也是对象，所以也有一个`__proto__`属性，它的构造函数是`Object`，所以构造函数的原型对象的`__proto__`指向`Object.prototype`。\n\n```\nPerson.prototype.__proto__ === Object.prototype; // true\n```\n\n最后，`Object.prototype`的`_proto`属性指向`null`。\n\n```\nObject.prototype.__proto__ === null; //true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/ppchain_sophie.jpg)\n\n需要加以区分的是，构造函数自身相当于`new Function`\b，它也是对象，也有一个`__proto__`属性指向自身构造函数的原型对象，即`Function.prototype`。\n\n```\nPerson.__proto__ === Function.prototype; // true\n```\n\n和构造函数的原型对象一样，`Function`的原型对象的`__proto__`也指向`Object.prototype`。最终指向`null`。\n\n```\nFunction.prototype.__proto__ === Object.prototype; // true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/ppchain_person.jpg)\n\n补充情况，当使用`Object.create()`的时候，新生成对象的`__proto__`会指向所传的参数，而不是`Object.prototype`。\n\n```\nvar ss = Object.create(sophie);\nss.__proto__ === sophie; // true\n```\n\n关于`prototype`和`__proto__`，推荐一篇个人觉得很好的博文：[三张图搞懂原型](https://www.cnblogs.com/shuiyi/p/5305435.html)。  \n&nbsp;\n\n### `new`\n\n```\nvar new2 = function(func) {\n  var obj = Object.create(func.prototype);\n  var returnVal = func.call(obj);\n  if (typeof returnVal === 'object') {\n    return returnVal;\n  } else {\n    return obj;\n  }\n}\n```\n\n如上图所示，`new`创建了一个空对象，将这个对象的`__proto__`指向构造函数的原型对象，并且调用构造函数的`call()`改变`this`的指针，相当于在对象上复制构造函数`this`绑定的属性。如果构造函数返回的不是对象类型，那么就返回这个新创建的对象。\n\n```\nfunction Person() {}\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 1; // true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp1.jpg)\n\n```\nfunction Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 2; // true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp2.jpg)\n\n```\nfunction Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {};\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 2; // true;\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp3.jpg)\n\n```\nfunction Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() { this.a = 3 };\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 3; // true;\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp4.jpg)\n&nbsp;  \n最后用一道题目，结束原型链。\n\n```\nfunction Parent(){\n  this.a = 1;\n  this.b = [2];\n}\nParent.prototype.c = [3];\nfunction Child(){}\nChild.prototype = new Parent();\n\nvar cc = new Child(); // cc.a = 1, cc.b = [2], cc.c = [3]\ncc.a = 's';\ncc.b.push('s');\ncc.c = ['s'];\n\nconsole.log(cc); // {a: 's', c: ['s']}\nconsole.log(Child.prototype.b); // [2, 's']\ncc.b === Child.prototype.b; // true\nconsole.log(Parent.prototype.c); // [3]\n```\n\n`cc`一开始是个空对象，通过原型链可以访问到`a`, `b`, `c`, `d`。给`cc`赋值会给它自身添加属性，一般不会修改原型链，除非修改的是引用类型。这里面也有区别，`cc.b`引用`Child.prototype.b`指向同一个对象, 所以会互相影响。而`cc.c`重新赋值指向一个新对象`['s']`，所以不会影响`Parent.prototype.c`。\n","source":"_posts/oop1.md","raw":"---\ntitle: 原型与new\ndate: 2017-02-22 17:51:47\ncategories: JavaScript\ntags: [OOP, Interview]\n---\n\n### `prototype`\n\n无论什么时候，只要创建了一个新函数，该函数就会创建一个`prototype`属性，指向这个函数的原型对象。这个原型对象里默认有一个属性：`constructor`，指向当前这个函数。\n\n```\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.constructor === Person; // true\n```\n\n&nbsp;\n\n### `__proto__`\n\n每个对象都有一个属性`__proto__`，它的指向取决于对象的创建方式，一般指向自身构造函数的原型对象（除了`Object.create()`）。本质是标准属性`[[Prototype]]`，由于`[[Prototype]]`不可见，Firefox、Safari、Chrome 浏览器实现了`__proto__`来访问。  \n实例化一个构造函数之后得到的实例化对象，它的`__proto__`属性就指向这个构造函数的`prototype`。\n\n```\nvar sophie = new Person('sophie');\nsophie.__proto__ === Person.prototype; // true\n```\n\n这个构造函数的原型对象也是对象，所以也有一个`__proto__`属性，它的构造函数是`Object`，所以构造函数的原型对象的`__proto__`指向`Object.prototype`。\n\n```\nPerson.prototype.__proto__ === Object.prototype; // true\n```\n\n最后，`Object.prototype`的`_proto`属性指向`null`。\n\n```\nObject.prototype.__proto__ === null; //true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/ppchain_sophie.jpg)\n\n需要加以区分的是，构造函数自身相当于`new Function`\b，它也是对象，也有一个`__proto__`属性指向自身构造函数的原型对象，即`Function.prototype`。\n\n```\nPerson.__proto__ === Function.prototype; // true\n```\n\n和构造函数的原型对象一样，`Function`的原型对象的`__proto__`也指向`Object.prototype`。最终指向`null`。\n\n```\nFunction.prototype.__proto__ === Object.prototype; // true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/ppchain_person.jpg)\n\n补充情况，当使用`Object.create()`的时候，新生成对象的`__proto__`会指向所传的参数，而不是`Object.prototype`。\n\n```\nvar ss = Object.create(sophie);\nss.__proto__ === sophie; // true\n```\n\n关于`prototype`和`__proto__`，推荐一篇个人觉得很好的博文：[三张图搞懂原型](https://www.cnblogs.com/shuiyi/p/5305435.html)。  \n&nbsp;\n\n### `new`\n\n```\nvar new2 = function(func) {\n  var obj = Object.create(func.prototype);\n  var returnVal = func.call(obj);\n  if (typeof returnVal === 'object') {\n    return returnVal;\n  } else {\n    return obj;\n  }\n}\n```\n\n如上图所示，`new`创建了一个空对象，将这个对象的`__proto__`指向构造函数的原型对象，并且调用构造函数的`call()`改变`this`的指针，相当于在对象上复制构造函数`this`绑定的属性。如果构造函数返回的不是对象类型，那么就返回这个新创建的对象。\n\n```\nfunction Person() {}\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 1; // true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp1.jpg)\n\n```\nfunction Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 2; // true\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp2.jpg)\n\n```\nfunction Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {};\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 2; // true;\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp3.jpg)\n\n```\nfunction Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() { this.a = 3 };\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 3; // true;\n```\n\n![avatar](http://osly086qe.bkt.clouddn.com/this_pp4.jpg)\n&nbsp;  \n最后用一道题目，结束原型链。\n\n```\nfunction Parent(){\n  this.a = 1;\n  this.b = [2];\n}\nParent.prototype.c = [3];\nfunction Child(){}\nChild.prototype = new Parent();\n\nvar cc = new Child(); // cc.a = 1, cc.b = [2], cc.c = [3]\ncc.a = 's';\ncc.b.push('s');\ncc.c = ['s'];\n\nconsole.log(cc); // {a: 's', c: ['s']}\nconsole.log(Child.prototype.b); // [2, 's']\ncc.b === Child.prototype.b; // true\nconsole.log(Parent.prototype.c); // [3]\n```\n\n`cc`一开始是个空对象，通过原型链可以访问到`a`, `b`, `c`, `d`。给`cc`赋值会给它自身添加属性，一般不会修改原型链，除非修改的是引用类型。这里面也有区别，`cc.b`引用`Child.prototype.b`指向同一个对象, 所以会互相影响。而`cc.c`重新赋值指向一个新对象`['s']`，所以不会影响`Parent.prototype.c`。\n","slug":"oop1","published":1,"updated":"2018-04-08T14:34:09.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqxyslb00079wfrd4zpsdr1","content":"<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a><code>prototype</code></h3><p>无论什么时候，只要创建了一个新函数，该函数就会创建一个<code>prototype</code>属性，指向这个函数的原型对象。这个原型对象里默认有一个属性：<code>constructor</code>，指向当前这个函数。</p>\n<pre><code>function Person(name) {\n  this.name = name;\n}\nPerson.prototype.constructor === Person; // true\n</code></pre><p>&nbsp;</p>\n<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a><code>__proto__</code></h3><p>每个对象都有一个属性<code>__proto__</code>，它的指向取决于对象的创建方式，一般指向自身构造函数的原型对象（除了<code>Object.create()</code>）。本质是标准属性<code>[[Prototype]]</code>，由于<code>[[Prototype]]</code>不可见，Firefox、Safari、Chrome 浏览器实现了<code>__proto__</code>来访问。<br>实例化一个构造函数之后得到的实例化对象，它的<code>__proto__</code>属性就指向这个构造函数的<code>prototype</code>。</p>\n<pre><code>var sophie = new Person(&#39;sophie&#39;);\nsophie.__proto__ === Person.prototype; // true\n</code></pre><p>这个构造函数的原型对象也是对象，所以也有一个<code>__proto__</code>属性，它的构造函数是<code>Object</code>，所以构造函数的原型对象的<code>__proto__</code>指向<code>Object.prototype</code>。</p>\n<pre><code>Person.prototype.__proto__ === Object.prototype; // true\n</code></pre><p>最后，<code>Object.prototype</code>的<code>_proto</code>属性指向<code>null</code>。</p>\n<pre><code>Object.prototype.__proto__ === null; //true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/ppchain_sophie.jpg\" alt=\"avatar\"></p>\n<p>需要加以区分的是，构造函数自身相当于<code>new Function</code>\b，它也是对象，也有一个<code>__proto__</code>属性指向自身构造函数的原型对象，即<code>Function.prototype</code>。</p>\n<pre><code>Person.__proto__ === Function.prototype; // true\n</code></pre><p>和构造函数的原型对象一样，<code>Function</code>的原型对象的<code>__proto__</code>也指向<code>Object.prototype</code>。最终指向<code>null</code>。</p>\n<pre><code>Function.prototype.__proto__ === Object.prototype; // true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/ppchain_person.jpg\" alt=\"avatar\"></p>\n<p>补充情况，当使用<code>Object.create()</code>的时候，新生成对象的<code>__proto__</code>会指向所传的参数，而不是<code>Object.prototype</code>。</p>\n<pre><code>var ss = Object.create(sophie);\nss.__proto__ === sophie; // true\n</code></pre><p>关于<code>prototype</code>和<code>__proto__</code>，推荐一篇个人觉得很好的博文：<a href=\"https://www.cnblogs.com/shuiyi/p/5305435.html\" target=\"_blank\" rel=\"noopener\">三张图搞懂原型</a>。<br>&nbsp;</p>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a><code>new</code></h3><pre><code>var new2 = function(func) {\n  var obj = Object.create(func.prototype);\n  var returnVal = func.call(obj);\n  if (typeof returnVal === &#39;object&#39;) {\n    return returnVal;\n  } else {\n    return obj;\n  }\n}\n</code></pre><p>如上图所示，<code>new</code>创建了一个空对象，将这个对象的<code>__proto__</code>指向构造函数的原型对象，并且调用构造函数的<code>call()</code>改变<code>this</code>的指针，相当于在对象上复制构造函数<code>this</code>绑定的属性。如果构造函数返回的不是对象类型，那么就返回这个新创建的对象。</p>\n<pre><code>function Person() {}\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 1; // true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp1.jpg\" alt=\"avatar\"></p>\n<pre><code>function Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 2; // true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp2.jpg\" alt=\"avatar\"></p>\n<pre><code>function Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {};\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 2; // true;\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp3.jpg\" alt=\"avatar\"></p>\n<pre><code>function Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() { this.a = 3 };\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 3; // true;\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp4.jpg\" alt=\"avatar\"><br>&nbsp;<br>最后用一道题目，结束原型链。</p>\n<pre><code>function Parent(){\n  this.a = 1;\n  this.b = [2];\n}\nParent.prototype.c = [3];\nfunction Child(){}\nChild.prototype = new Parent();\n\nvar cc = new Child(); // cc.a = 1, cc.b = [2], cc.c = [3]\ncc.a = &#39;s&#39;;\ncc.b.push(&#39;s&#39;);\ncc.c = [&#39;s&#39;];\n\nconsole.log(cc); // {a: &#39;s&#39;, c: [&#39;s&#39;]}\nconsole.log(Child.prototype.b); // [2, &#39;s&#39;]\ncc.b === Child.prototype.b; // true\nconsole.log(Parent.prototype.c); // [3]\n</code></pre><p><code>cc</code>一开始是个空对象，通过原型链可以访问到<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>。给<code>cc</code>赋值会给它自身添加属性，一般不会修改原型链，除非修改的是引用类型。这里面也有区别，<code>cc.b</code>引用<code>Child.prototype.b</code>指向同一个对象, 所以会互相影响。而<code>cc.c</code>重新赋值指向一个新对象<code>[&#39;s&#39;]</code>，所以不会影响<code>Parent.prototype.c</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a><code>prototype</code></h3><p>无论什么时候，只要创建了一个新函数，该函数就会创建一个<code>prototype</code>属性，指向这个函数的原型对象。这个原型对象里默认有一个属性：<code>constructor</code>，指向当前这个函数。</p>\n<pre><code>function Person(name) {\n  this.name = name;\n}\nPerson.prototype.constructor === Person; // true\n</code></pre><p>&nbsp;</p>\n<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"__proto__\"></a><code>__proto__</code></h3><p>每个对象都有一个属性<code>__proto__</code>，它的指向取决于对象的创建方式，一般指向自身构造函数的原型对象（除了<code>Object.create()</code>）。本质是标准属性<code>[[Prototype]]</code>，由于<code>[[Prototype]]</code>不可见，Firefox、Safari、Chrome 浏览器实现了<code>__proto__</code>来访问。<br>实例化一个构造函数之后得到的实例化对象，它的<code>__proto__</code>属性就指向这个构造函数的<code>prototype</code>。</p>\n<pre><code>var sophie = new Person(&#39;sophie&#39;);\nsophie.__proto__ === Person.prototype; // true\n</code></pre><p>这个构造函数的原型对象也是对象，所以也有一个<code>__proto__</code>属性，它的构造函数是<code>Object</code>，所以构造函数的原型对象的<code>__proto__</code>指向<code>Object.prototype</code>。</p>\n<pre><code>Person.prototype.__proto__ === Object.prototype; // true\n</code></pre><p>最后，<code>Object.prototype</code>的<code>_proto</code>属性指向<code>null</code>。</p>\n<pre><code>Object.prototype.__proto__ === null; //true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/ppchain_sophie.jpg\" alt=\"avatar\"></p>\n<p>需要加以区分的是，构造函数自身相当于<code>new Function</code>\b，它也是对象，也有一个<code>__proto__</code>属性指向自身构造函数的原型对象，即<code>Function.prototype</code>。</p>\n<pre><code>Person.__proto__ === Function.prototype; // true\n</code></pre><p>和构造函数的原型对象一样，<code>Function</code>的原型对象的<code>__proto__</code>也指向<code>Object.prototype</code>。最终指向<code>null</code>。</p>\n<pre><code>Function.prototype.__proto__ === Object.prototype; // true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/ppchain_person.jpg\" alt=\"avatar\"></p>\n<p>补充情况，当使用<code>Object.create()</code>的时候，新生成对象的<code>__proto__</code>会指向所传的参数，而不是<code>Object.prototype</code>。</p>\n<pre><code>var ss = Object.create(sophie);\nss.__proto__ === sophie; // true\n</code></pre><p>关于<code>prototype</code>和<code>__proto__</code>，推荐一篇个人觉得很好的博文：<a href=\"https://www.cnblogs.com/shuiyi/p/5305435.html\" target=\"_blank\" rel=\"noopener\">三张图搞懂原型</a>。<br>&nbsp;</p>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a><code>new</code></h3><pre><code>var new2 = function(func) {\n  var obj = Object.create(func.prototype);\n  var returnVal = func.call(obj);\n  if (typeof returnVal === &#39;object&#39;) {\n    return returnVal;\n  } else {\n    return obj;\n  }\n}\n</code></pre><p>如上图所示，<code>new</code>创建了一个空对象，将这个对象的<code>__proto__</code>指向构造函数的原型对象，并且调用构造函数的<code>call()</code>改变<code>this</code>的指针，相当于在对象上复制构造函数<code>this</code>绑定的属性。如果构造函数返回的不是对象类型，那么就返回这个新创建的对象。</p>\n<pre><code>function Person() {}\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 1; // true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp1.jpg\" alt=\"avatar\"></p>\n<pre><code>function Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {}\nStudent.prototype = new Person();\nStudent.prototype.a === 2; // true\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp2.jpg\" alt=\"avatar\"></p>\n<pre><code>function Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() {};\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 2; // true;\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp3.jpg\" alt=\"avatar\"></p>\n<pre><code>function Person() { this.a = 2 };\nPerson.prototype.a = 1;\nfunction Student() { this.a = 3 };\nStudent.prototype = new Person();\nvar s = new Student();\ns.a === 3; // true;\n</code></pre><p><img src=\"http://osly086qe.bkt.clouddn.com/this_pp4.jpg\" alt=\"avatar\"><br>&nbsp;<br>最后用一道题目，结束原型链。</p>\n<pre><code>function Parent(){\n  this.a = 1;\n  this.b = [2];\n}\nParent.prototype.c = [3];\nfunction Child(){}\nChild.prototype = new Parent();\n\nvar cc = new Child(); // cc.a = 1, cc.b = [2], cc.c = [3]\ncc.a = &#39;s&#39;;\ncc.b.push(&#39;s&#39;);\ncc.c = [&#39;s&#39;];\n\nconsole.log(cc); // {a: &#39;s&#39;, c: [&#39;s&#39;]}\nconsole.log(Child.prototype.b); // [2, &#39;s&#39;]\ncc.b === Child.prototype.b; // true\nconsole.log(Parent.prototype.c); // [3]\n</code></pre><p><code>cc</code>一开始是个空对象，通过原型链可以访问到<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>。给<code>cc</code>赋值会给它自身添加属性，一般不会修改原型链，除非修改的是引用类型。这里面也有区别，<code>cc.b</code>引用<code>Child.prototype.b</code>指向同一个对象, 所以会互相影响。而<code>cc.c</code>重新赋值指向一个新对象<code>[&#39;s&#39;]</code>，所以不会影响<code>Parent.prototype.c</code>。</p>\n"},{"title":"类型进阶","date":"2018-02-19T14:40:41.000Z","_content":"\n本篇内容总结于网易前端微专业的 Javascript 程序设计和慕课网的前端跳槽面试必备技巧，并进行了相应扩展。\n\n### 类型检测\n\n![img](http://osly086qe.bkt.clouddn.com/typeof.jpg)\n\n```\ntypeof null; // 'object'\ntypeof function(){}; // 'function'\nlet s = new Symbol('uid');\ntypeof s; // 'symbol'\nclass PersonClass { ... };\ntypeof PersonClass; // 'function'\n```\n\n`typeof()`可以检测除`null`以外的基本类型和`Function`类型。\n\n&nbsp;\n\n![img](http://osly086qe.bkt.clouddn.com/instanceof.jpg)\n\n```\n[] instanceof Array; // true\n'jerry' instanceof String; // false\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nfunction Circle(x, y, r) {\n    Point.call(this, x, y);\n    this.radius = r;\n}\nCircle.prototype = new Point();\nCircle.prototype.constructor = Circle;\n\nvar c = new Circle(1, 1, 2);\nc instanceof Circle; // true\nc instanceof Point; // true\n```\n\n`instanceof`可以检测所有的对象类型（包括内置对象类型和自定义对象类型），不能检测基本类型。  \n`instanceof`的原理是检查`c`的原型链上是否有`Circle.prototype`和`Point.prototype`。在`iframe`下`instanceof`就会不生效，因为处于不同的上下文。另外，`instanceof undefined`会报错，右边不是一个对象。\n\n&nbsp;\n\n![img](http://osly086qe.bkt.clouddn.com/toString.jpg)\n\n```\nfunction type(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\ntype(null); // 'Null'\ntype(new Date); // 'Date'\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\ntype(new Point(1, 2)); // 'Object'\n```\n\n`Object.prototype.toString.call()`可以检测基本类型和内置对象类型，但不能检测自定义对象类型。\n\n&nbsp;\n\n![img](http://osly086qe.bkt.clouddn.com/constructor.jpg)\n\n```\n(1).constructor === Number; // true\n[].constructor === Array; // true\n\nfunction Person(name) {\n    this.name = name;\n}\nnew Person('jerry').constructor === Person; // true\n\nfunction getConstructorName(obj) {\n    return obj && obj.constuctor && obj.constructor.toString().match(/function\\s*([^(]*)/)[1];\n}\ngetConstructorName([]) === 'Array'; // true\n```\n\n`constructor`可以检测除`null`和`undefined`以外的基本类型和所有的对象类型。但由于`constructor`是可以被修改的，所以要当心。  \n&nbsp;\n\n### 显式类型转换\n\n`Number(str)`：比`parseInt(str)`严格：纯数字转成数字，否则`NaN`，`' '`和`null`转为 0。  \n`Number(obj)`：先隐式调用`obj.valueOf()`，返回原始类型就直接调`Number()`，否则调用`obj.toString()`，返回原始类型再调`Number()`，否则报错。\n\n`String(obj)`：与`Number(obj)`相反。先隐式调用`obj.toString()`，返回原始类型就直接调`String()`，否则调用`obj.valueOf()`，返回原始类型再调`String()`，否则报错。\n\n`Boolean()`：`undefined`，`null`，0，`NaN`，`' '`会转为`false`，其余都是`true`（尤其是`[]`和`{}`）。  \n&nbsp;\n\n### 隐式类型转换\n\n四则运算、判断语句、Native 调用（比如`console`和`alert`）会发生隐式类型转换。\n\n```\ntrue + true; // 2\n[] + []; // '', String([]) + String([])\n[] + {}; // '[object Object]', String([]) + String({})\n```\n\n`{} + []`，`{}`会被当做代码块而忽略，执行`+[]`，相当于`Number([])`，所以结果是 0。  \n`{} + {}`，在 Chrome 下结果是`'[object Object][object Object]'`，相当于`String({}) + String({})`。在 Firefox 下结果是`NaN`，`{}`再次被当成是代码块而忽略，求值`Number({})`。  \n`1 + {a: 1}`相当于`String(1) + String({a: 1})`，所以结果是`'1[object Object]'`。\n","source":"_posts/type.md","raw":"---\ntitle: 类型进阶\ndate: 2018-02-19 22:40:41\ncategories: JavaScript\ntags: Interview\n---\n\n本篇内容总结于网易前端微专业的 Javascript 程序设计和慕课网的前端跳槽面试必备技巧，并进行了相应扩展。\n\n### 类型检测\n\n![img](http://osly086qe.bkt.clouddn.com/typeof.jpg)\n\n```\ntypeof null; // 'object'\ntypeof function(){}; // 'function'\nlet s = new Symbol('uid');\ntypeof s; // 'symbol'\nclass PersonClass { ... };\ntypeof PersonClass; // 'function'\n```\n\n`typeof()`可以检测除`null`以外的基本类型和`Function`类型。\n\n&nbsp;\n\n![img](http://osly086qe.bkt.clouddn.com/instanceof.jpg)\n\n```\n[] instanceof Array; // true\n'jerry' instanceof String; // false\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nfunction Circle(x, y, r) {\n    Point.call(this, x, y);\n    this.radius = r;\n}\nCircle.prototype = new Point();\nCircle.prototype.constructor = Circle;\n\nvar c = new Circle(1, 1, 2);\nc instanceof Circle; // true\nc instanceof Point; // true\n```\n\n`instanceof`可以检测所有的对象类型（包括内置对象类型和自定义对象类型），不能检测基本类型。  \n`instanceof`的原理是检查`c`的原型链上是否有`Circle.prototype`和`Point.prototype`。在`iframe`下`instanceof`就会不生效，因为处于不同的上下文。另外，`instanceof undefined`会报错，右边不是一个对象。\n\n&nbsp;\n\n![img](http://osly086qe.bkt.clouddn.com/toString.jpg)\n\n```\nfunction type(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\ntype(null); // 'Null'\ntype(new Date); // 'Date'\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\ntype(new Point(1, 2)); // 'Object'\n```\n\n`Object.prototype.toString.call()`可以检测基本类型和内置对象类型，但不能检测自定义对象类型。\n\n&nbsp;\n\n![img](http://osly086qe.bkt.clouddn.com/constructor.jpg)\n\n```\n(1).constructor === Number; // true\n[].constructor === Array; // true\n\nfunction Person(name) {\n    this.name = name;\n}\nnew Person('jerry').constructor === Person; // true\n\nfunction getConstructorName(obj) {\n    return obj && obj.constuctor && obj.constructor.toString().match(/function\\s*([^(]*)/)[1];\n}\ngetConstructorName([]) === 'Array'; // true\n```\n\n`constructor`可以检测除`null`和`undefined`以外的基本类型和所有的对象类型。但由于`constructor`是可以被修改的，所以要当心。  \n&nbsp;\n\n### 显式类型转换\n\n`Number(str)`：比`parseInt(str)`严格：纯数字转成数字，否则`NaN`，`' '`和`null`转为 0。  \n`Number(obj)`：先隐式调用`obj.valueOf()`，返回原始类型就直接调`Number()`，否则调用`obj.toString()`，返回原始类型再调`Number()`，否则报错。\n\n`String(obj)`：与`Number(obj)`相反。先隐式调用`obj.toString()`，返回原始类型就直接调`String()`，否则调用`obj.valueOf()`，返回原始类型再调`String()`，否则报错。\n\n`Boolean()`：`undefined`，`null`，0，`NaN`，`' '`会转为`false`，其余都是`true`（尤其是`[]`和`{}`）。  \n&nbsp;\n\n### 隐式类型转换\n\n四则运算、判断语句、Native 调用（比如`console`和`alert`）会发生隐式类型转换。\n\n```\ntrue + true; // 2\n[] + []; // '', String([]) + String([])\n[] + {}; // '[object Object]', String([]) + String({})\n```\n\n`{} + []`，`{}`会被当做代码块而忽略，执行`+[]`，相当于`Number([])`，所以结果是 0。  \n`{} + {}`，在 Chrome 下结果是`'[object Object][object Object]'`，相当于`String({}) + String({})`。在 Firefox 下结果是`NaN`，`{}`再次被当成是代码块而忽略，求值`Number({})`。  \n`1 + {a: 1}`相当于`String(1) + String({a: 1})`，所以结果是`'1[object Object]'`。\n","slug":"type","published":1,"updated":"2018-04-08T14:49:40.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfqxyslc00089wfroa5mr7l0","content":"<p>本篇内容总结于网易前端微专业的 Javascript 程序设计和慕课网的前端跳槽面试必备技巧，并进行了相应扩展。</p>\n<h3 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h3><p><img src=\"http://osly086qe.bkt.clouddn.com/typeof.jpg\" alt=\"img\"></p>\n<pre><code>typeof null; // &#39;object&#39;\ntypeof function(){}; // &#39;function&#39;\nlet s = new Symbol(&#39;uid&#39;);\ntypeof s; // &#39;symbol&#39;\nclass PersonClass { ... };\ntypeof PersonClass; // &#39;function&#39;\n</code></pre><p><code>typeof()</code>可以检测除<code>null</code>以外的基本类型和<code>Function</code>类型。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://osly086qe.bkt.clouddn.com/instanceof.jpg\" alt=\"img\"></p>\n<pre><code>[] instanceof Array; // true\n&#39;jerry&#39; instanceof String; // false\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nfunction Circle(x, y, r) {\n    Point.call(this, x, y);\n    this.radius = r;\n}\nCircle.prototype = new Point();\nCircle.prototype.constructor = Circle;\n\nvar c = new Circle(1, 1, 2);\nc instanceof Circle; // true\nc instanceof Point; // true\n</code></pre><p><code>instanceof</code>可以检测所有的对象类型（包括内置对象类型和自定义对象类型），不能检测基本类型。<br><code>instanceof</code>的原理是检查<code>c</code>的原型链上是否有<code>Circle.prototype</code>和<code>Point.prototype</code>。在<code>iframe</code>下<code>instanceof</code>就会不生效，因为处于不同的上下文。另外，<code>instanceof undefined</code>会报错，右边不是一个对象。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://osly086qe.bkt.clouddn.com/toString.jpg\" alt=\"img\"></p>\n<pre><code>function type(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\ntype(null); // &#39;Null&#39;\ntype(new Date); // &#39;Date&#39;\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\ntype(new Point(1, 2)); // &#39;Object&#39;\n</code></pre><p><code>Object.prototype.toString.call()</code>可以检测基本类型和内置对象类型，但不能检测自定义对象类型。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://osly086qe.bkt.clouddn.com/constructor.jpg\" alt=\"img\"></p>\n<pre><code>(1).constructor === Number; // true\n[].constructor === Array; // true\n\nfunction Person(name) {\n    this.name = name;\n}\nnew Person(&#39;jerry&#39;).constructor === Person; // true\n\nfunction getConstructorName(obj) {\n    return obj &amp;&amp; obj.constuctor &amp;&amp; obj.constructor.toString().match(/function\\s*([^(]*)/)[1];\n}\ngetConstructorName([]) === &#39;Array&#39;; // true\n</code></pre><p><code>constructor</code>可以检测除<code>null</code>和<code>undefined</code>以外的基本类型和所有的对象类型。但由于<code>constructor</code>是可以被修改的，所以要当心。<br>&nbsp;</p>\n<h3 id=\"显式类型转换\"><a href=\"#显式类型转换\" class=\"headerlink\" title=\"显式类型转换\"></a>显式类型转换</h3><p><code>Number(str)</code>：比<code>parseInt(str)</code>严格：纯数字转成数字，否则<code>NaN</code>，<code>&#39; &#39;</code>和<code>null</code>转为 0。<br><code>Number(obj)</code>：先隐式调用<code>obj.valueOf()</code>，返回原始类型就直接调<code>Number()</code>，否则调用<code>obj.toString()</code>，返回原始类型再调<code>Number()</code>，否则报错。</p>\n<p><code>String(obj)</code>：与<code>Number(obj)</code>相反。先隐式调用<code>obj.toString()</code>，返回原始类型就直接调<code>String()</code>，否则调用<code>obj.valueOf()</code>，返回原始类型再调<code>String()</code>，否则报错。</p>\n<p><code>Boolean()</code>：<code>undefined</code>，<code>null</code>，0，<code>NaN</code>，<code>&#39; &#39;</code>会转为<code>false</code>，其余都是<code>true</code>（尤其是<code>[]</code>和<code>{}</code>）。<br>&nbsp;</p>\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>四则运算、判断语句、Native 调用（比如<code>console</code>和<code>alert</code>）会发生隐式类型转换。</p>\n<pre><code>true + true; // 2\n[] + []; // &#39;&#39;, String([]) + String([])\n[] + {}; // &#39;[object Object]&#39;, String([]) + String({})\n</code></pre><p><code>{} + []</code>，<code>{}</code>会被当做代码块而忽略，执行<code>+[]</code>，相当于<code>Number([])</code>，所以结果是 0。<br><code>{} + {}</code>，在 Chrome 下结果是<code>&#39;[object Object][object Object]&#39;</code>，相当于<code>String({}) + String({})</code>。在 Firefox 下结果是<code>NaN</code>，<code>{}</code>再次被当成是代码块而忽略，求值<code>Number({})</code>。<br><code>1 + {a: 1}</code>相当于<code>String(1) + String({a: 1})</code>，所以结果是<code>&#39;1[object Object]&#39;</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇内容总结于网易前端微专业的 Javascript 程序设计和慕课网的前端跳槽面试必备技巧，并进行了相应扩展。</p>\n<h3 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h3><p><img src=\"http://osly086qe.bkt.clouddn.com/typeof.jpg\" alt=\"img\"></p>\n<pre><code>typeof null; // &#39;object&#39;\ntypeof function(){}; // &#39;function&#39;\nlet s = new Symbol(&#39;uid&#39;);\ntypeof s; // &#39;symbol&#39;\nclass PersonClass { ... };\ntypeof PersonClass; // &#39;function&#39;\n</code></pre><p><code>typeof()</code>可以检测除<code>null</code>以外的基本类型和<code>Function</code>类型。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://osly086qe.bkt.clouddn.com/instanceof.jpg\" alt=\"img\"></p>\n<pre><code>[] instanceof Array; // true\n&#39;jerry&#39; instanceof String; // false\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nfunction Circle(x, y, r) {\n    Point.call(this, x, y);\n    this.radius = r;\n}\nCircle.prototype = new Point();\nCircle.prototype.constructor = Circle;\n\nvar c = new Circle(1, 1, 2);\nc instanceof Circle; // true\nc instanceof Point; // true\n</code></pre><p><code>instanceof</code>可以检测所有的对象类型（包括内置对象类型和自定义对象类型），不能检测基本类型。<br><code>instanceof</code>的原理是检查<code>c</code>的原型链上是否有<code>Circle.prototype</code>和<code>Point.prototype</code>。在<code>iframe</code>下<code>instanceof</code>就会不生效，因为处于不同的上下文。另外，<code>instanceof undefined</code>会报错，右边不是一个对象。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://osly086qe.bkt.clouddn.com/toString.jpg\" alt=\"img\"></p>\n<pre><code>function type(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1);\n}\ntype(null); // &#39;Null&#39;\ntype(new Date); // &#39;Date&#39;\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\ntype(new Point(1, 2)); // &#39;Object&#39;\n</code></pre><p><code>Object.prototype.toString.call()</code>可以检测基本类型和内置对象类型，但不能检测自定义对象类型。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://osly086qe.bkt.clouddn.com/constructor.jpg\" alt=\"img\"></p>\n<pre><code>(1).constructor === Number; // true\n[].constructor === Array; // true\n\nfunction Person(name) {\n    this.name = name;\n}\nnew Person(&#39;jerry&#39;).constructor === Person; // true\n\nfunction getConstructorName(obj) {\n    return obj &amp;&amp; obj.constuctor &amp;&amp; obj.constructor.toString().match(/function\\s*([^(]*)/)[1];\n}\ngetConstructorName([]) === &#39;Array&#39;; // true\n</code></pre><p><code>constructor</code>可以检测除<code>null</code>和<code>undefined</code>以外的基本类型和所有的对象类型。但由于<code>constructor</code>是可以被修改的，所以要当心。<br>&nbsp;</p>\n<h3 id=\"显式类型转换\"><a href=\"#显式类型转换\" class=\"headerlink\" title=\"显式类型转换\"></a>显式类型转换</h3><p><code>Number(str)</code>：比<code>parseInt(str)</code>严格：纯数字转成数字，否则<code>NaN</code>，<code>&#39; &#39;</code>和<code>null</code>转为 0。<br><code>Number(obj)</code>：先隐式调用<code>obj.valueOf()</code>，返回原始类型就直接调<code>Number()</code>，否则调用<code>obj.toString()</code>，返回原始类型再调<code>Number()</code>，否则报错。</p>\n<p><code>String(obj)</code>：与<code>Number(obj)</code>相反。先隐式调用<code>obj.toString()</code>，返回原始类型就直接调<code>String()</code>，否则调用<code>obj.valueOf()</code>，返回原始类型再调<code>String()</code>，否则报错。</p>\n<p><code>Boolean()</code>：<code>undefined</code>，<code>null</code>，0，<code>NaN</code>，<code>&#39; &#39;</code>会转为<code>false</code>，其余都是<code>true</code>（尤其是<code>[]</code>和<code>{}</code>）。<br>&nbsp;</p>\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>四则运算、判断语句、Native 调用（比如<code>console</code>和<code>alert</code>）会发生隐式类型转换。</p>\n<pre><code>true + true; // 2\n[] + []; // &#39;&#39;, String([]) + String([])\n[] + {}; // &#39;[object Object]&#39;, String([]) + String({})\n</code></pre><p><code>{} + []</code>，<code>{}</code>会被当做代码块而忽略，执行<code>+[]</code>，相当于<code>Number([])</code>，所以结果是 0。<br><code>{} + {}</code>，在 Chrome 下结果是<code>&#39;[object Object][object Object]&#39;</code>，相当于<code>String({}) + String({})</code>。在 Firefox 下结果是<code>NaN</code>，<code>{}</code>再次被当成是代码块而忽略，求值<code>Number({})</code>。<br><code>1 + {a: 1}</code>相当于<code>String(1) + String({a: 1})</code>，所以结果是<code>&#39;1[object Object]&#39;</code>。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjfqxysl100009wfrezyjts29","category_id":"cjfqxysl800049wfrbhziwo2c","_id":"cjfqxyslf000c9wfrjdw2oxkg"},{"post_id":"cjfqxysl600029wfrxywhiy3r","category_id":"cjfqxysl800049wfrbhziwo2c","_id":"cjfqxyslg000f9wfrja4kj70y"},{"post_id":"cjfqxysla00069wfr18xc4rth","category_id":"cjfqxyslf000b9wfr2va8brac","_id":"cjfqxysli000k9wfr1ix32ueq"},{"post_id":"cjfqxyslb00079wfrd4zpsdr1","category_id":"cjfqxyslf000b9wfr2va8brac","_id":"cjfqxysli000o9wfrbp4f28ur"},{"post_id":"cjfqxyslc00089wfroa5mr7l0","category_id":"cjfqxyslf000b9wfr2va8brac","_id":"cjfqxyslj000q9wfrcvrisvfe"}],"PostTag":[{"post_id":"cjfqxysl100009wfrezyjts29","tag_id":"cjfqxysla00059wfrevnp23x6","_id":"cjfqxyslg000e9wfrie8vu3jv"},{"post_id":"cjfqxysl100009wfrezyjts29","tag_id":"cjfqxysld000a9wfrnf3pmbvb","_id":"cjfqxyslg000g9wfru4nn5i1s"},{"post_id":"cjfqxysl600029wfrxywhiy3r","tag_id":"cjfqxysla00059wfrevnp23x6","_id":"cjfqxysli000m9wfr5zezn2vu"},{"post_id":"cjfqxysl600029wfrxywhiy3r","tag_id":"cjfqxysld000a9wfrnf3pmbvb","_id":"cjfqxysli000n9wfr4ii22m1e"},{"post_id":"cjfqxysla00069wfr18xc4rth","tag_id":"cjfqxysli000l9wfryosrgl5a","_id":"cjfqxyslj000s9wfrqenk8fhw"},{"post_id":"cjfqxysla00069wfr18xc4rth","tag_id":"cjfqxysld000a9wfrnf3pmbvb","_id":"cjfqxyslj000t9wfr5k272ywp"},{"post_id":"cjfqxyslb00079wfrd4zpsdr1","tag_id":"cjfqxysli000l9wfryosrgl5a","_id":"cjfqxyslk000w9wfr1atu9aqy"},{"post_id":"cjfqxyslb00079wfrd4zpsdr1","tag_id":"cjfqxysld000a9wfrnf3pmbvb","_id":"cjfqxyslk000x9wfrgz5nj1is"},{"post_id":"cjfqxyslc00089wfroa5mr7l0","tag_id":"cjfqxysld000a9wfrnf3pmbvb","_id":"cjfqxyslk000y9wfrgj5uga8u"}],"Tag":[{"name":"Layout","_id":"cjfqxysla00059wfrevnp23x6"},{"name":"Interview","_id":"cjfqxysld000a9wfrnf3pmbvb"},{"name":"OOP","_id":"cjfqxysli000l9wfryosrgl5a"}]}}